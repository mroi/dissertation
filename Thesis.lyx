#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass tufte-book
\begin_preamble
% letter spacing for capitalized text
\renewcommand{\allcapsspacing}[1]{{\addfontfeature{LetterSpace=6.5}#1}}
\renewcommand{\smallcapsspacing}[1]{{\addfontfeature{LetterSpace=5.0,Letters=SmallCaps}#1}}

% font setup: because we want to set the math font also, we cannot use LyX’s font options
\usepackage[MnSymbol]{mathspec}
\setmainfont[Mapping=tex-text,ItalicFeatures={Contextuals={NoLineInitial,NoLineFinal}}]{Hoefler Text}
\setsansfont[Mapping=tex-text]{Gill Sans}
\setmonofont[Scale=0.85]{Menlo Regular}
\setmathsfont(Digits,Latin)[ItalicFeatures={Contextuals={NoLineInitial,NoLineFinal}},Numbers=Lining]{Hoefler Text}
%\setmathsfont(Greek){Georgia}

% use all-bullets for itemize and give them the right size and height
\AtBeginDocument{
\def\labelitemi{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemii{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemiii{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemiv{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
}

% simplified title and author for fancy headers, height-correct the dash
\renewcommand{\plaintitle}{Practical Real\raisebox{-0.45mm}{-}Time}
\renewcommand{\plainauthor}{Michael Roitzsch}

% enable colored page edge when a new chapter starts
\newcommand{\chapteredge}{
\fancypagestyle{plain}{
\fancyhf{}
\fancyfoot[LE,RO]{
\begin{picture}(0,0)
\color{gray}
\put(49,-60){\rule{10mm}{305mm}}
\end{picture}
}}}

% epigraph command
\newcommand{\epigraph}[2]{
\begin{fullwidth}
\sffamily\large
\begin{doublespace}
\noindent\allcaps{#1}\\% epigraph
\noindent\allcaps{#2}% author
\end{doublespace}
\end{fullwidth}
}
\end_preamble
\options a4paper
\use_default_options true
\begin_modules
fixltx2e
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Style Verleger
Margin	Static
LatexType	Command
Category	FrontMatter
LatexName	publisher
InTitle	1
InPreamble	1
Font
Size	Large
EndFont
End

InsetLayout Flex:AllCaps
CopyStyle AllCaps
End

InsetLayout Flex:SmallCaps
CopyStyle SmallCaps
End
\end_local_layout
\language english
\language_package default
\inputencoding utf8-plain
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Practical Real-Time: System Support for Modern Applications"
\pdf_author "Michael Roitzsch"
\pdf_subject "Dissertation"
\pdf_keywords "Real-Time, Multicore, Work Queues, Clairvoyance"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "linktoc=all, pdfborder=2 2 0.5, linkbordercolor=0.8 0.8 1, urlbordercolor=0.6 1 0.6"
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 1
\tocdepth 2
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Itemize
Greek letters in math mode are still typeset in computer modern.
 Enabling Georgia as a replacement (see preamble section in document settings)
 hangs 
\family typewriter
xelatex
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
frontmatter
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
null
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
epigraph{For I dipt into the future, far as human eye could see,
\backslash
newline
\backslash
noindent saw the vision of the world, and all the wonder that would be.}{Alfred
 Lord Tennyson}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
This first epigraph feels the most out-of-place of the three.
 Can we find something more software- or technology-related?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
epigraph{The art of prophecy is very difficult,
\backslash
newline
\backslash
noindent especially with respect to the future.}{Mark Twain}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
epigraph{Oh dear! Oh dear! I shall be too late!}{The White Rabbit}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Author
Michael Roitzsch – born August 15, 1980
\end_layout

\begin_layout Title
Practical Real
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
raisebox{0.8mm}{-}
\end_layout

\end_inset

Time:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

A Look-Ahead Scheduler for
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Modern Applications
\end_layout

\begin_layout Verleger
Dissertation
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Advisor: Prof.
 Dr.
 rer.
 nat.
 Hermann Härtig
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset


\lang ngerman
Technische Universität Dresden
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
null
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset


\begin_inset Graphics
	filename Figures/TU-Logo.pdf
	width 5cm

\end_inset


\end_layout

\begin_layout Full Width

\lang ngerman
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout

\lang ngerman
Dissertation
\end_layout

\end_inset

 zur Erlangung des akademischen Grades 
\begin_inset Flex AllCaps
status collapsed

\begin_layout Plain Layout

\lang ngerman
Doktoringenieur (Dr.-Ing.)
\end_layout

\end_inset

, vorgelegt an der 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout

\lang ngerman
Technischen Universität Dresden, Fakultät Informatik
\end_layout

\end_inset

, eingereicht von 
\begin_inset Flex AllCaps
status collapsed

\begin_layout Plain Layout

\lang ngerman
Dipl.-Inf.
 Michael Roitzsch
\end_layout

\end_inset

, geboren am 15.
 August 1980 in Dresden.
\end_layout

\begin_layout Full Width

\lang ngerman
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt" special="@{}l">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Betreuender Hochschullehrer:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Prof.
 Dr.
 rer.
 nat.
 Hermann Härtig,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Technische Universität Dresden
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Fachreferent:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Prof.
 Dr.
 Christof Fetzer,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Technische Universität Dresden
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Gutachter:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\lang ngerman
fehlt
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Statusvortrag:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
12.
 Dezember 2011
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Tag der Verteidigung:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\lang ngerman
fehlt
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Full Width
\begin_inset VSpace defskip
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset


\lang ngerman
Dresden, 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\lang ngerman
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Acknowledgments
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
OS group, Prof.
 Härtig, fellow researchers, friends, parents
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList margintable

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Full Width
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
null
\end_layout

\end_inset


\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent
\backslash
nohyphenation 
\end_layout

\end_inset


\shape italic
\size huge

\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\shape italic
\size huge
Dedication
\end_layout

\end_inset


\end_layout

\begin_layout Full Width
\begin_inset VSpace vfill
\end_inset


\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Chapter*
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
these are hard times for developers
\end_layout

\begin_deeper
\begin_layout Itemize
users demand not only functionality, but are now used to quick responsiveness,
 speedy applications and low energy use
\end_layout

\begin_layout Itemize
these are hard problems:
\end_layout

\begin_deeper
\begin_layout Itemize
responsiveness in the face of non-real-time operating systems
\end_layout

\begin_layout Itemize
speed in the face of stagnating single-core frequency, increasing core counts
 and heterogeneity (GPUs)
\end_layout

\begin_layout Itemize
load adaptation without global knowledge or fairness
\end_layout

\begin_layout Itemize
energy characteristics typically dictated and managed behind the scenes
 by hardware
\end_layout

\end_deeper
\begin_layout Itemize
some of these goals are at odds: speed vs.
 energy, throughput vs.
 responsiveness
\end_layout

\end_deeper
\begin_layout Itemize
these are hard times for the scheduler
\end_layout

\begin_layout Itemize
large body of research in these individual topics is available
\end_layout

\begin_deeper
\begin_layout Itemize
this dissertation tries to summarize existing work
\end_layout

\begin_layout Itemize
provide a holistic view and enhance state-of-the-art with key contributions
\end_layout

\end_deeper
\begin_layout Itemize
driving insights
\end_layout

\begin_deeper
\begin_layout Itemize
applications are increasingly structured into work packets (see 
\begin_inset CommandInset ref
LatexCommand nameref
reference "chap:Anatomy"

\end_inset

)
\end_layout

\begin_layout Itemize
some limited help by the application can provide insightful clairvoyance
\end_layout

\begin_layout Itemize
allows ahead-of-time decisions rather than post-mortem control
\end_layout

\end_deeper
\begin_layout Itemize
apply this idea to real-time, parallelism, energy and adaptivity
\end_layout

\begin_deeper
\begin_layout Itemize
work packets help for parallelism
\end_layout

\begin_layout Itemize
deadlines can naturally be assigned to groups of work packets, hints help
 training execution time prediction
\end_layout

\begin_layout Itemize
deadlines also enable batching to save energy
\end_layout

\begin_layout Itemize
adaptation can specify alternative execution paths with costs and benefits
\end_layout

\begin_layout Itemize
implementations in alternative ISAs allow using specialized hardware (GPGPU,
 fixed-function units) with time or energy benefits
\end_layout

\begin_layout Itemize
our focus: combining real-time and parallelism, name contributions here
\end_layout

\begin_layout Itemize
end-to-end-solutions must consider three levels: workload, application,
 system
\end_layout

\begin_deeper
\begin_layout Itemize
collaboration between system and application is beneficial
\end_layout

\begin_layout Itemize
combine application-specific knowledge with general mechanism, not either-or
\end_layout

\begin_layout Itemize
table or summary figure with columns/swim lanes for topics and layers for
 levels
\end_layout

\begin_layout Itemize
provide main thesis statement and clear-cut contributions
\end_layout

\end_deeper
\begin_layout Itemize
overview of the organization of this text (with forward references)
\end_layout

\end_deeper
\begin_layout Itemize
goal: programming paradigm that must be manageable for developers
\end_layout

\begin_deeper
\begin_layout Itemize
mainstream programming for mere mortals instead of only for a priesthood
\end_layout

\begin_layout Itemize
targets interactive systems (desktop, notebook, smartphone), not reactive
 systems (industrial control, deeply embedded)
\end_layout

\begin_layout Itemize
formulate other goals?
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mainmatter
\backslash
chapteredge
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Anatomy"

\end_inset

Anatomy of a Modern Desktop Application
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
major change in application structure
\end_layout

\begin_deeper
\begin_layout Itemize
single-threaded
\end_layout

\begin_deeper
\begin_layout Itemize
UI blocks on every user-triggered activity
\end_layout

\begin_layout Itemize
unresponsive, not parallel, but simple code
\end_layout

\end_deeper
\begin_layout Itemize
multithreaded
\end_layout

\begin_deeper
\begin_layout Itemize
focus on responsiveness, do long-running work asynchronously off the UI
 thread
\end_layout

\begin_layout Itemize
threading is not concurrency (Jim Held, MARC symposium keynote), we saw
 that when moving to multicores
\end_layout

\begin_layout Itemize
explicit thread management with hard-coded or guessed thread count
\end_layout

\begin_layout Itemize
difficult code
\end_layout

\end_deeper
\begin_layout Itemize
today: work packets
\end_layout

\begin_deeper
\begin_layout Itemize
the UI thread (main thread) does no real work (see microkernel paradigm),
 it merely dispatches (spine-analogy) to keep things busy
\end_layout

\begin_layout Itemize
similar to networks moving from switched circuits to packet routing
\end_layout

\begin_layout Itemize
analogy: packet-switching in the phone network, railway trains on a track
 network
\begin_inset CommandInset citation
LatexCommand cite
key "MacResearch:AboardGrandCentral"

\end_inset


\end_layout

\begin_layout Itemize
work set model
\begin_inset CommandInset citation
LatexCommand cite
key "Kulkarni:Galois"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
executing some work packets can add new work packets to the set
\end_layout

\begin_layout Itemize
useful to implement irregular algorithms (processing on graph-like data
 structures with pointers, opposite: dense array)
\end_layout

\end_deeper
\begin_layout Itemize
set down the terminology here: 
\begin_inset Quotes eld
\end_inset

work packets
\begin_inset Quotes erd
\end_inset

 or just 
\begin_inset Quotes eld
\end_inset

work
\begin_inset Quotes erd
\end_inset

 to denote those items of code+state
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
implementations of work packet programming
\end_layout

\begin_deeper
\begin_layout Itemize
lambdas/closures/blocks/tasks/activities as useful abstraction for declaring
 a piece of work inline: code looks serial, logical locality
\end_layout

\begin_layout Itemize
Microsoft: 
\begin_inset Formula $\lambda$
\end_inset

-functions turn out to be the holy-grail feature
\begin_inset CommandInset citation
LatexCommand cite
key "Sutter:C++AMP_Keynote"

\end_inset

 for developing the parallel patterns library as a library
\end_layout

\begin_layout Itemize
four aspects: logical locality, automatic state capture, asynchronous invocation
, automatic thread management
\end_layout

\begin_layout Itemize
closures solve the first two, work queues the other two
\end_layout

\begin_deeper
\begin_layout Itemize
keep pending packets, automatic thread assignment and pooling, system-wide
 thread balancing
\end_layout

\begin_layout Itemize
thread count becomes controllable
\end_layout

\begin_layout Itemize
goal: have the number of active threads match the number of (logical) cores
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:SchedulerActivations"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
do a table with checkmarks comparing different implementations of the paradigm
\end_layout

\begin_deeper
\begin_layout Itemize
Apple GCD, Microsoft PPL
\begin_inset CommandInset citation
LatexCommand cite
key "MSDN:C++PPL"

\end_inset

, X10
\begin_inset CommandInset citation
LatexCommand cite
key "Charles:X10"

\end_inset

: all four
\end_layout

\begin_layout Itemize
cross-thread signal-slot-connections in Qt
\begin_inset CommandInset citation
LatexCommand cite
key "Qt:SignalsSlotsThreads"

\end_inset

: asynchronous method calls, no automatic thread management, no automatic
 state-capturing
\end_layout

\begin_layout Itemize
Go-routines in Google Go: asynchronous method calls, automatic thread management
, no automatic state-capturing
\end_layout

\begin_layout Itemize
TaskC model for Core Manager
\begin_inset CommandInset citation
LatexCommand cite
key "Arnold:TaskC"

\end_inset

: asynchronous task spawning but not nested, automatic placement decision,
 manual statue capture because its not shared memory
\end_layout

\begin_layout Itemize
OpenMP for regular algorithms like iterating over dense arrays, mostly paralleli
zing loops: automatic thread assignment, guided self-scheduling to reduce
 dispatching overhead, synchronous
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
result of this architecture: most work is done asynchronously and is announced
 by the application ahead-of-time
\end_layout

\begin_deeper
\begin_layout Itemize
limited view into the future as a common trait for modern applications (this
 is a key point here)
\end_layout

\begin_layout Itemize
work packets (or groups of them) are natural receivers for metadata by the
 developer (deadlines) or automatically by the system (training)
\end_layout

\begin_layout Itemize
this thesis: What kind of metadata can we use to what benefit?
\end_layout

\end_deeper
\begin_layout Itemize
introduce video as the primary demo application
\end_layout

\begin_deeper
\begin_layout Itemize
good sample workload, because it covers many properties: real-time, compute
 intensive, subject to energy savings, potentially adaptive
\end_layout

\begin_layout Itemize
other application to validate claims more comprehensively
\end_layout

\end_deeper
\begin_layout Itemize
the future: increasing heterogeneity
\end_layout

\begin_deeper
\begin_layout Itemize
only a limited teaser here, do not overload readers, but provide enough
 segue for the later chapters to build upon
\end_layout

\begin_layout Itemize
pieces of GPU code (and other ISAs with tighter assumptions and less ability)
 interwoven with CPU code
\end_layout

\begin_layout Itemize
devices like GPU (and increasingly network cards
\begin_inset CommandInset citation
LatexCommand cite
key "Nightingale:Helios"

\end_inset

) treated as compute resources like CPU, not as a peripheral
\end_layout

\begin_layout Itemize
mostly out of scope for this work, but will consider hardware video decoders
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Real-Time"

\end_inset

Real Simple Real
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
raisebox{-0.45mm}{-}
\end_layout

\end_inset

Time
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
many applications have intrinsic real-time characteristics
\end_layout

\begin_deeper
\begin_layout Itemize
real-time naturally surfaces when computers interact with the real world,
 in both input and output
\end_layout

\begin_layout Itemize
all desktops do that, yet almost no desktop software uses real-time programming
\end_layout

\begin_layout Itemize
deadlines for UI code driven by usability requirements: 10/100/1000
\begin_inset space \thinspace{}
\end_inset

ms
\end_layout

\begin_layout Itemize
obvious for animations, which become increasingly ubiquitous and which should
 not stutter if they are supposed to help usability by supporting mental
 transitions
\end_layout

\begin_layout Itemize
even harder for touch-based interaction, where lag of UI breaks the user's
 mental link of interacting with on-screen items directly
\end_layout

\begin_layout Itemize
often buried within the application and not expressed
\end_layout

\begin_layout Itemize
real-time used to be a rare special case, but it should become default;
 this work tries to pave the way
\end_layout

\end_deeper
\begin_layout Itemize
real-time programming: spectrum between strong guarantees + complex programming
 and weak guarantees + simple programming
\end_layout

\begin_deeper
\begin_layout Itemize
complicated contracts to express resource needs (examples needed)
\end_layout

\begin_layout Itemize
admission: yet another error condition for the developer, how to communicate
 refusal to the user?
\end_layout

\begin_layout Itemize
existing commodity systems
\end_layout

\begin_deeper
\begin_layout Itemize
Android: all Dalvik threads use SCHED_OTHER 
\begin_inset CommandInset citation
LatexCommand cite
key "Maia:AndroidRT"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
things should be simplified to become widely accepted by developers
\end_layout

\begin_deeper
\begin_layout Itemize
express requirements with deadlines only
\end_layout

\begin_layout Itemize
this is an attribute within the application's problem domain
\end_layout

\begin_deeper
\begin_layout Itemize
system cannot guess it
\end_layout

\begin_layout Itemize
developers should be able to provide it
\end_layout

\end_deeper
\begin_layout Itemize
no complex contracts, no admission but deal with overload
\end_layout

\end_deeper
\begin_layout Itemize
deriving architecture from requirements
\end_layout

\begin_deeper
\begin_layout Itemize
execution time is workload-dependent, deadlines are application-specific:
 application-view needed
\end_layout

\begin_layout Itemize
scheduling must distribute load (potentially) across all compute resources:
 global view needed
\end_layout

\begin_layout Itemize
application-level component and global scheduler must work together
\end_layout

\end_deeper
\begin_layout Itemize
clairvoyance
\end_layout

\begin_deeper
\begin_layout Itemize
for autonomous computing tasks, applications already know what lies ahead
\end_layout

\begin_deeper
\begin_layout Itemize
only code and data determine the upcoming computation, both are known ahead-of-t
ime
\end_layout

\begin_layout Itemize
counterexample: direct, low-latency reaction to user input
\end_layout

\end_deeper
\begin_layout Itemize
given the asynchronous execution model discussed above, this future execution
 can be exposed as real-time jobs early
\end_layout

\begin_deeper
\begin_layout Itemize
hints are needed to predict execution times
\end_layout

\begin_layout Itemize
must stay within application domain
\end_layout

\begin_layout Itemize
individual work packets may be too fine-grained
\end_layout

\begin_deeper
\begin_layout Itemize
model jobs as groups of work packets
\end_layout

\begin_layout Itemize
attach deadlines there
\end_layout

\begin_layout Itemize
GCD supports those
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
use this knowledge to provide insightful clairvoyance
\end_layout

\begin_layout Itemize
previous work usually depends on black-box guessing and post-mortem control
\end_layout

\begin_deeper
\begin_layout Itemize
state the key advancement here and forward-reference to the full related
 work discussion
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
end-to-end solution
\end_layout

\begin_deeper
\begin_layout Itemize
workload: analyze dependency between data and execution time – execution
 time metrics for video
\begin_inset CommandInset citation
LatexCommand cite
key "roitzsch06:predict"

\end_inset


\end_layout

\begin_layout Itemize
application: offer look into the future, derive execution time prediction
 from hints, attach deadlines to jobs, propagate knowledge down to system
 level
\end_layout

\begin_layout Itemize
system: insert all jobs in an EDF run queue
\end_layout

\end_deeper
\begin_layout Itemize
explain online execution time training in detail
\end_layout

\begin_deeper
\begin_layout Itemize
with evaluation
\end_layout

\begin_layout Itemize
G-EDF is optimal for soft real-time
\begin_inset CommandInset citation
LatexCommand cite
key "Devi:GEDFTardiness"

\end_inset


\end_layout

\begin_layout Itemize
useful bounded tardiness characteristics: allows unrealistic deadlines,
 like 0 for low latency 
\begin_inset Quotes eld
\end_inset

right now
\begin_inset Quotes erd
\end_inset

 work
\end_layout

\begin_deeper
\begin_layout Itemize
however: unbounded deadline misses under overload
\end_layout

\end_deeper
\begin_layout Itemize
use infinite deadline for best effort background activity
\end_layout

\begin_layout Itemize
break ties in round-robin fashion
\end_layout

\begin_layout Itemize
G-EDF scales for today's core counts, in the future we may want to consider
 clustered scheduling
\begin_inset CommandInset citation
LatexCommand cite
key "Calandrino:ClusteredEDF"

\end_inset


\end_layout

\begin_layout Itemize
efficient EDF implementation strategies are known
\begin_inset CommandInset citation
LatexCommand cite
key "Short:EDFTaskManagement"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
discuss related work in detail
\end_layout

\begin_deeper
\begin_layout Itemize
Redline
\begin_inset CommandInset citation
LatexCommand cite
key "Yang:Redline"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Redline Slides"
target "http://os.inf.tu-dresden.de/local/dropscon/archive/2008-12-03-Michael-Redline.pdf"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
coop_poll
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:CoopPoll"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
also uses application insight, no black-box approach
\end_layout

\begin_layout Itemize
propagates application's task descriptions down to the kernel
\end_layout

\end_deeper
\begin_layout Itemize
two-level scheduling
\begin_inset CommandInset citation
LatexCommand cite
key "Shin:Compositional"

\end_inset


\end_layout

\begin_layout Itemize
Constant Bandwidth Server
\begin_inset CommandInset citation
LatexCommand cite
key "Abeni:CBS"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
also employs EDF as the fundamental scheduler
\end_layout

\begin_layout Itemize
provides temporal isolation: protect hard real-time tasks from the messy
 soft real-time tasks
\end_layout

\begin_layout Itemize
server manages the deadlines (assignment, postponing), not the application
\end_layout

\begin_layout Itemize
does not target improving the soft-real time workload, thus somewhat orthogonal
 to this work
\end_layout

\begin_layout Itemize
could be used to provide isolated hard real-time load in our system
\end_layout

\end_deeper
\begin_layout Itemize
reservation-based approaches
\begin_inset CommandInset citation
LatexCommand cite
key "Abeni:AdaptiveReservations"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
similarities: no worst-case planning, because it is wasteful; no focus on
 preventing every single deadline violation
\end_layout

\begin_deeper
\begin_layout Itemize
overload handling instead of admission
\end_layout

\begin_layout Itemize
two layer approach: dedicated controller per task like HDE
\end_layout

\end_deeper
\begin_layout Itemize
different world view: illusion of a dedicated slower processor
\end_layout

\begin_deeper
\begin_layout Itemize
fluid flow allocation contradicts the work packet style, more amenable to
 threads
\end_layout

\end_deeper
\begin_layout Itemize
dynamic bandwidth adaptation to workflow as an afterthought
\end_layout

\begin_deeper
\begin_layout Itemize
black-box control vs.
 insightful cooperation using hints
\end_layout

\begin_layout Itemize
my predictor can be used in a reservation-based system
\end_layout

\begin_layout Itemize
still: post-mortem adaptation vs.
 clairvoyance
\end_layout

\end_deeper
\begin_layout Itemize
finishing work until the deadline matters, abstracting from the application's
 work pattern using reservations makes this harder to accomplish and requires
 more complexity in control layer
\end_layout

\begin_deeper
\begin_layout Itemize
slack reclaiming added
\begin_inset CommandInset citation
LatexCommand cite
key "Palopoli:FeedbackReclaiming"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
gratuitously applying control theory might cover up the real interactions
 of components and tries to recreate them in another layer
\end_layout

\end_deeper
\begin_layout Itemize
device IO
\end_layout

\begin_deeper
\begin_layout Itemize
propagate deadlines to device queues when jobs issue IO requests
\end_layout

\begin_layout Itemize
GCD fosters asynchronous device access and queue-ahead of upcoming jobs:
 provides the same clairvoyance for device IO
\end_layout

\begin_layout Itemize
devices become smart and self-schedule: manage the queue themselves
\end_layout

\begin_deeper
\begin_layout Itemize
example: interrupt rate limiting, low-latency packet override and another
 rate limiting for the low-latency override in Intel 82576 network card
\begin_inset CommandInset citation
LatexCommand cite
key "Intel_NIC"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Dynamic Active Subset helps
\begin_inset CommandInset citation
LatexCommand cite
key "Reuther:DAS"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ARTIFACT
\begin_inset CommandInset citation
LatexCommand cite
key "Sasinowski:ARTIFACT"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
ubiquitous priorities, MPEG execution model hard, load-shedding (forward
 reference to adaptivity)
\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Parallelism"

\end_inset

Scheduling meets Multicore
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
looked at situation from a developer perspective so far, now combine with
 a view from below
\end_layout

\begin_layout Itemize
trend: context switching considered harmful
\end_layout

\begin_deeper
\begin_layout Itemize
increase efficiency by avoiding mode switches
\end_layout

\begin_layout Itemize
we used to shred everything to little pieces, stir, and then execute
\end_layout

\begin_deeper
\begin_layout Itemize
this used to be practical when many threads needed to be multiplexed in
 quasi-parallel fashion on one CPU
\end_layout

\begin_layout Itemize
with the number of cores approaching the number of ready threads, this approach
 gets impractical
\end_layout

\end_deeper
\begin_layout Itemize
many other resources cannot be preempted
\end_layout

\begin_deeper
\begin_layout Itemize
especially with GPUs: way too much state to save and restore
\end_layout

\begin_layout Itemize
careful: GPUs get preempt-and-resume functionality, but is it efficient?
\end_layout

\end_deeper
\begin_layout Itemize
CPUs are going this way too
\end_layout

\begin_deeper
\begin_layout Itemize
flushing cache, TLB, branch predictor, prefetcher becomes prohibitively
 expensive
\end_layout

\begin_layout Itemize
micro-benchmarks show cache-miss-related slowdown caused by only the timer
 tick
\begin_inset CommandInset citation
LatexCommand cite
key "Tsafrir:OSNoise"

\end_inset


\end_layout

\begin_layout Itemize
hardware transactional memory aborts on context switch
\begin_inset CommandInset citation
LatexCommand cite
key "AMD_ASF_Spec"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
HPC applications have always used batch-style operation
\end_layout

\begin_deeper
\begin_layout Itemize
no context switching 
\begin_inset Quotes eld
\end_inset

in the small
\begin_inset Quotes erd
\end_inset

 on one node, because it would throw off barrier-synced code that assumes
 to run ganged
\end_layout

\begin_layout Itemize
no context switching 
\begin_inset Quotes eld
\end_inset

in the big
\begin_inset Quotes erd
\end_inset

 on the entire machine, multiple jobs run concurrently by static assignment
 of nodes
\end_layout

\begin_layout Itemize
HPC often uses static placement that is decided offline, but dynamic HPC
 workloads exist that need dynamic decision-making
\end_layout

\begin_layout Itemize
example: particle system, work packets correspond to patches of physical
 space, number of particles currently in the patch determines amount of
 work
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
work queues that are drained asynchronously fit in here well
\end_layout

\begin_deeper
\begin_layout Itemize
main benefit of queues/bags of work: no forced control-flow transfer, work
 is executed at the target’s discretion
\end_layout

\begin_layout Itemize
other than with threads, work queues just offer parallelism, dispatching
 is separate, system can decide placement
\end_layout

\begin_deeper
\begin_layout Itemize
number of threads becomes controllable instead of being fixed in the application
 code
\end_layout

\begin_layout Itemize
careful: there is also user-level threading, but this again has the context-swit
ch problem, just on another level
\end_layout

\end_deeper
\begin_layout Itemize
work queues used within applications and also down to the kernel
\begin_inset CommandInset citation
LatexCommand cite
key "Soares:FlexSC"

\end_inset


\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/Queues Mode Switches.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Work queues prevent mode switches.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
improves throughput and (surprisingly) also latency when loaded
\end_layout

\begin_layout Itemize
extends the spine+worker programming model to workloads where the kernel
 is the worker (i.e.
 Internet servers)
\end_layout

\begin_layout Itemize
notifications from kernel to user space could work asynchronously, but don't
 as far as I know, closest: kqueue
\begin_inset CommandInset citation
LatexCommand cite
key "Lemon:Kqueue"

\end_inset


\end_layout

\begin_layout Itemize
DSI on L4 provides asynchronous data movement between different address
 spaces
\end_layout

\begin_layout Itemize
many throughput-oriented drivers (network cards) work this way, too
\end_layout

\begin_layout Itemize
work queues also used to drive GPUs predictably
\begin_inset CommandInset citation
LatexCommand cite
key "Kato:Timegraph"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
combination of both the above: systems increasingly schedule in space instead
 of time
\end_layout

\begin_deeper
\begin_layout Itemize
parallelism is replacing frequency scaling as the means to increase performance
\end_layout

\begin_layout Itemize
placement and migration replace context switching as the scheduling mechanism
\end_layout

\begin_layout Itemize
scheduling is now placement + order: two dimensions
\end_layout

\begin_layout Itemize
Lampson predicted this
\begin_inset CommandInset citation
LatexCommand cite
key "Lampson:HintsDesign"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

split resources in a fixed way if in doubt, rather than sharing them
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
multiplex as long as hardware is expensive, statically assign once hardware
 is cheap
\end_layout

\end_deeper
\begin_layout Itemize
specialize cores dynamically to execute kernel services
\end_layout

\end_deeper
\begin_layout Itemize
real-time section covered time dimension, now look at space dimension
\end_layout

\begin_deeper
\begin_layout Itemize
using asynchronous blocks for parallelism and deadlines and hints attached
 to block groups for real-time, both are decoupled
\end_layout

\begin_layout Itemize
execution time estimates give us the total execution time, but when spread
 across cores, it might take less wall-clock time
\end_layout

\begin_layout Itemize
how much less (i.e.
 the parallel efficiency) and how much parallelism can be offered (i.e.
 the parallel degree) should be provided by the application or observed
 by the runtime
\end_layout

\end_deeper
\begin_layout Itemize
end-to-end solution
\end_layout

\begin_deeper
\begin_layout Itemize
workload: make amenable for data-parallel processing like intrinsic load-balanci
ng
\begin_inset CommandInset citation
LatexCommand cite
key "roitzsch07:balancing"

\end_inset


\end_layout

\begin_layout Itemize
application: offer parallelism to the system, provide estimates on parallel
 degree and efficiency
\end_layout

\begin_layout Itemize
system: place jobs on cores and order in time based on deadlines, execution
 time estimates and parallelism
\end_layout

\end_deeper
\begin_layout Itemize
describe parallel workload and placement algorithm in detail
\end_layout

\begin_deeper
\begin_layout Itemize
video parallelization techniques (slice, macroblock-wave)
\end_layout

\begin_layout Itemize
system communicates consequences of placement decision back to the application
\end_layout

\begin_deeper
\begin_layout Itemize
number of threads to be used by GCD runtime
\end_layout

\begin_layout Itemize
avoid context-switch, so no upcall interface, but info-page-style shared
 memory
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
discuss related work in detail
\end_layout

\begin_deeper
\begin_layout Itemize
schedule in space instead of in time
\end_layout

\begin_deeper
\begin_layout Itemize
OS design for systems with 1000+ cores focus on space sharing instead of
 time sharing
\begin_inset CommandInset citation
LatexCommand cite
key "Wentzlaff:fos"

\end_inset


\end_layout

\begin_layout Itemize
even stronger separation between cores: explicit communication instead of
 cache coherent shared memory
\begin_inset CommandInset citation
LatexCommand cite
key "Baumann:Barrelfish"

\end_inset


\end_layout

\begin_layout Itemize
run parts of the system close or on the device they target
\begin_inset CommandInset citation
LatexCommand cite
key "Nightingale:Helios"

\end_inset


\end_layout

\begin_layout Itemize
placement of jobs on cores influences contention on caches, prefetcher and
 DRAM controller
\begin_inset CommandInset citation
LatexCommand cite
key "Zhuravlev:DIO"

\end_inset


\end_layout

\begin_layout Itemize
on NUMA-systems, placement influences memory latency
\begin_inset CommandInset citation
LatexCommand cite
key "Blagodurov:DINO"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
developed placement strategies can augment our placement algorithm
\end_layout

\begin_deeper
\begin_layout Itemize
fits well with our programming model of applications exposing metadata on
 parallel work
\end_layout

\begin_layout Itemize
performance counters often used for runtime monitoring, like online cache
 utility modeling
\begin_inset CommandInset citation
LatexCommand cite
key "West:CacheUtility"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
the execution order of work packets within a job is relevant for speed and
 cache working set size
\begin_inset CommandInset citation
LatexCommand cite
key "Chen:ConstructiveCacheSharing"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
use a lightweight specification language to describe beneficial scheduling
 policies
\begin_inset CommandInset citation
LatexCommand cite
key "Nguyen:ConcurrentSchedulers"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
hardware extensions supporting work queues and reduced context switching
\end_layout

\begin_deeper
\begin_layout Itemize
NVIDIA Fermi uses GigaThread hardware to decide placement
\begin_inset CommandInset citation
LatexCommand cite
key "NVIDIA_Fermi"

\end_inset


\end_layout

\begin_layout Itemize
Core Manager distributes work and its data to processing elements
\begin_inset CommandInset citation
LatexCommand cite
key "Limberg:Tomahawk"

\end_inset


\end_layout

\begin_layout Itemize
Asynchronous Direct Messages
\begin_inset CommandInset citation
LatexCommand cite
key "Sanchez:ADM"

\end_inset

 allow very fine-grained work packets
\end_layout

\begin_deeper
\begin_layout Itemize
more flexible: small hardware extension to be used by work queue implementation
\end_layout

\begin_layout Itemize
allows exposing more parallelism by splitting into smaller work packets
\end_layout

\begin_layout Itemize
scalable because of local queues and work stealing that bypasses the memory
 hierarchy
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
knowledge about the job layout in both space and time allows disabling the
 periodic timer tick
\end_layout

\begin_deeper
\begin_layout Itemize
dynamically dedicate cores: place work somewhere, then let it run without
 interference
\end_layout

\begin_layout Itemize
currently, the timer-tick is OS-level polling, hits all cores no matter
 what they run
\end_layout

\begin_layout Itemize
moving to a tickless kernel helps to reducing OS noise and energy consumption
\end_layout

\begin_layout Itemize
good for barrier-sync-style HPC applications: even the timer interrupt hurts
 them badly
\begin_inset CommandInset citation
LatexCommand cite
key "Tsafrir:OSNoise"

\end_inset


\end_layout

\begin_layout Itemize
suggested solution: demand-driven 
\begin_inset Quotes eld
\end_inset

smart
\begin_inset Quotes erd
\end_inset

 timers which allow for batching instead of the slavish periodic tick
\end_layout

\begin_layout Itemize
idea is an extension to timers with precision
\begin_inset CommandInset citation
LatexCommand cite
key "Peter:30Seconds"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
holistic approach for distributed systems: MOSIX
\end_layout

\begin_deeper
\begin_layout Itemize
load balancing on networks of computers, predicts future problems within
 manycores
\end_layout

\begin_layout Itemize
increasing message latency between cores relative to compute speed: placement
 of work and communication patterns relevant
\end_layout

\begin_layout Itemize
employs gossiping to establish global system view without a central authority
\end_layout

\begin_layout Itemize
ad-hoc solution for my approach: assume that work packets of the same job
 are more likely to talk to each other, place closer together
\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Adaptivity"

\end_inset

Under- and Overload
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
secondary policies on underload
\end_layout

\begin_deeper
\begin_layout Itemize
batch work by moving it around in the scheduling window to enable longer
 sleep times
\begin_inset CommandInset citation
LatexCommand cite
key "Awan:EnhancedRaceToHalt"

\end_inset


\end_layout

\begin_layout Itemize
idea has been discussed for timers, specifying timeout and precision to
 allow batching
\begin_inset CommandInset citation
LatexCommand cite
key "Peter:30Seconds"

\end_inset


\end_layout

\begin_layout Itemize
migrate to prevent fan noise or throttling
\begin_inset CommandInset citation
LatexCommand cite
key "Merkel:EnergyModel"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
backpressure on overload
\end_layout

\begin_deeper
\begin_layout Itemize
our 
\begin_inset Quotes eld
\end_inset

no admission
\begin_inset Quotes erd
\end_inset

 policy requires us to deal with overloads when the work does not fit within
 the deadlines
\end_layout

\begin_layout Itemize
load shedding is an old concept
\begin_inset CommandInset citation
LatexCommand cite
key "Lampson:HintsDesign"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

shed load to control demand, rather than allowing the system to become overloade
d.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Robert Morris idea: red button next to terminal, push when dissatisfied,
 system must raise your QoS or throw you off
\end_layout

\begin_layout Itemize
this old idea already argued for quality-aware adaptation, not just load-aware
\end_layout

\begin_layout Itemize
when overloaded, real-time applications become brittle and show bi-modal
 fairness
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:PriorityProgress"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
some work just needs to be done, no discussion, no adaptation possible
\end_layout

\begin_deeper
\begin_layout Itemize
I would argue this is the common case
\end_layout

\begin_layout Itemize
we can only hope to compensate by using the most efficient compute resource
 and organize it the most efficient way
\end_layout

\end_deeper
\begin_layout Itemize
some work can adapt, so exert backpressure
\end_layout

\begin_deeper
\begin_layout Itemize
some applications can make quality/resource trade-offs according to application-
specific notion of quality
\end_layout

\begin_deeper
\begin_layout Itemize
video is one example
\end_layout

\begin_layout Itemize
this also applies to resources other than CPU time, like network bandwidth
 for streaming
\end_layout

\end_deeper
\begin_layout Itemize
end-to-end solution
\end_layout

\begin_deeper
\begin_layout Itemize
workload: offer different processing paths, trading resources and quality
\end_layout

\begin_layout Itemize
application: under given resource constraints, find a quality-optimal path
 through this lattice of options
\end_layout

\begin_layout Itemize
system: distribute computing resource cutbacks in a quality-fair fashion
\end_layout

\end_deeper
\begin_layout Itemize
describe fallback decoding path for video
\begin_inset CommandInset citation
LatexCommand cite
key "roitzsch08:videoquality"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
decoding time estimate already given by HDE, quality estimate needed
\end_layout

\begin_layout Itemize
greedy solution for (contrained) binpacking: order jobs by quality/resource
 ratio
\end_layout

\end_deeper
\begin_layout Itemize
other sources for adaptive video
\end_layout

\begin_deeper
\begin_layout Itemize
SVC
\end_layout

\begin_layout Itemize
adaptive streaming protocols: application propagates backpressure even to
 the server
\end_layout

\end_deeper
\begin_layout Itemize
backpressure needs to be quality-fair, not resource-fair, but the quality
 scale is application specific and does not compare
\end_layout

\begin_deeper
\begin_layout Itemize
global quality-scheduling too complex, resort to balanced backpressure and
 per-application adaptivity
\end_layout

\begin_layout Itemize
needs help from the applications: provide percentage of missed deadlines
 relative to the maximum quality case, that represents the bare minimum
 quality users will accept
\end_layout

\begin_layout Itemize
backpressure will be distributed amongst adaptive applications weighted
 by this minimum quality
\end_layout

\begin_layout Itemize
assumption: linear quality drop from meeting all deadlines down to that
 percentage
\end_layout

\begin_layout Itemize
use of percentage of missed deadlines as quality parameter inspired by QRMS
\begin_inset CommandInset citation
LatexCommand cite
key "hamann07:qrms"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
related approaches
\end_layout

\begin_deeper
\begin_layout Itemize
overload handling with adaptive reservations
\begin_inset CommandInset citation
LatexCommand cite
key "Abeni:AdaptiveReservations"

\end_inset


\end_layout

\begin_layout Itemize
prioritize work and skip the low priorities when congested
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:PriorityProgress"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
simple quality-aware scheme
\end_layout

\begin_layout Itemize
global priority-monotonic ordering of video frames
\end_layout

\begin_layout Itemize
unclear how much of the fairness benefits stem from the priority sorting
 or just from global queueing
\end_layout

\end_deeper
\begin_layout Itemize
virtual time for progress fairness
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:CoopPoll"

\end_inset


\end_layout

\begin_layout Itemize
load-shedding queues in network servers
\begin_inset CommandInset citation
LatexCommand cite
key "Welsh:SEDA"

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
Past, Present and Future
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
changing paradigm of computing, future: always on, always connected
\end_layout

\begin_deeper
\begin_layout Itemize
smartphones, tablets and the cloud usher in a new era
\end_layout

\begin_layout Itemize
mobile computing, but still with responsiveness and smooth video demanded
 by users
\end_layout

\begin_layout Itemize
battery and energy constraints added to the problem space
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

energy is the new speed
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
energy works differently
\end_layout

\begin_deeper
\begin_layout Itemize
deadlines are inherent to the application, energy limitations are driven
 by the long-term intent of the user
\end_layout

\begin_layout Itemize
many existing solutions throttle threads according to an energy budget,
 but that's thinking inside the box 
\begin_inset CommandInset citation
LatexCommand cite
key "Roy:Cinder"

\end_inset


\end_layout

\begin_layout Itemize
assuming software does only useful work against the user's stated intent,
 throttling makes no sense
\end_layout

\begin_layout Itemize
only energy efficiency (doing the same with less energy) and maybe adaptivity
 remains
\end_layout

\end_deeper
\begin_layout Itemize
energy saving by batching is already enabled by clairvoyant deadline-knowledge
\end_layout

\begin_deeper
\begin_layout Itemize
batch network requests to power up radio less often 
\begin_inset CommandInset citation
LatexCommand cite
key "Roy:Cinder"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
we may have targeted hardware with reduced instruction sets available that
 is more energy-efficient
\end_layout

\begin_layout Itemize
hardware video decoders are an edge-case of this spectrum: very limited
 instructions or fixed function
\end_layout

\begin_deeper
\begin_layout Itemize
saves some energy (up to 25%
\begin_inset CommandInset citation
LatexCommand cite
key "LeSueur:SlowDownSleep"

\end_inset

), but not game-changing savings
\end_layout

\begin_layout Itemize
treat as any coprocessor that work with tighter restrictions on the available
 instructions can be offloaded to (see 
\family typewriter
restrict
\family default
 keyword proposal
\begin_inset CommandInset citation
LatexCommand cite
key "Sutter:C++AMP_Keynote"

\end_inset

)
\end_layout

\begin_layout Itemize
special-purpose devices offer more choice for job placement and change energy
 tradeoffs, but they do not eliminate the fundamental problem to get given
 work done (meeting given deadlines) with as little resources (energy, time)
 as possible
\end_layout

\begin_layout Itemize
choosing between race-to-halt and slowdown depends on workload and platform
\begin_inset CommandInset citation
LatexCommand cite
key "LeSueur:SlowDownSleep"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
end-to-end solution: this is only a rough sketch
\end_layout

\begin_deeper
\begin_layout Itemize
workload: energy-aware encoding of video
\end_layout

\begin_layout Itemize
application: maintain energy model, adapt to save energy, use specialized
 hardware
\end_layout

\begin_layout Itemize
system: collect and act on energy metrics, provide interface to specialized
 hardware
\end_layout

\end_deeper
\begin_layout Itemize
metadata to decide energy consequences can be collected per-job at runtime
\end_layout

\begin_deeper
\begin_layout Itemize
performance counter can help to tell memory- and CPU-bound jobs apart
\end_layout

\begin_deeper
\begin_layout Itemize
clocking down the CPU especially helpful for memory-bound jobs
\begin_inset CommandInset citation
LatexCommand cite
key "Snowdon:Koala"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
linear combination of metrics to predict energy in a similar way to the
 execution time
\end_layout

\begin_deeper
\begin_layout Itemize
performance counters to train energy model
\begin_inset CommandInset citation
LatexCommand cite
key "Merkel:EnergyModel"

\end_inset


\end_layout

\begin_layout Itemize
energy counter in Intel Sandy Bridge CPUs
\end_layout

\end_deeper
\begin_layout Itemize
work queues can clairvoyantly carry per-job energy metadata
\end_layout

\begin_deeper
\begin_layout Itemize
clock CPU down and then run all pending memory-bound jobs
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
using backpressure also for energy-management
\end_layout

\begin_deeper
\begin_layout Itemize
some applications can adapt their energy or computation time needs
\begin_inset CommandInset citation
LatexCommand cite
key "Flinn:EnergyAdaptation"

\end_inset


\end_layout

\begin_layout Itemize
trivial examples (disable backup on low battery) are rather obvious and
 not interesting, more dynamic examples are rare
\end_layout

\begin_layout Itemize
use energy instead of CPU time as a cost metric in adaptation decisions
\end_layout

\end_deeper
\begin_layout Itemize
hardware becomes less reliable
\end_layout

\begin_deeper
\begin_layout Itemize
hardware and OS-features to manage reliability explicitly
\end_layout

\begin_layout Itemize
provide GCD queues with different reliability levels, like imprecise ALU/FPU
\end_layout

\begin_layout Itemize
application can dispatch code blocks with different reliability requirements
\end_layout

\begin_deeper
\begin_layout Itemize
video decoders can tolerate some imprecision
\end_layout

\begin_layout Itemize
substring search can do the long scan unreliably, followed by a quick reliable
 check
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
future development is well covered by the presented design
\end_layout

\begin_layout Itemize
summarize the key contributions again
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
backmatter
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setlength{
\backslash
labelwidth}{0mm}
\backslash
setlength{
\backslash
labelsep}{0mm} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Bibliography/Thesis,Bibliography/Master"
options "Bibliography/Thesis"

\end_inset


\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
