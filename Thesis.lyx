#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass tufte-book
\begin_preamble
% letter spacing for capitalized text
\renewcommand{\allcapsspacing}[1]{{\addfontfeature{LetterSpace=6.5}#1}}
\renewcommand{\smallcapsspacing}[1]{{\addfontfeature{LetterSpace=5.0,Letters=SmallCaps}#1}}

% font setup: because we want to set the math font also, we cannot use LyX’s font options
\usepackage[MnSymbol]{mathspec}
\setmainfont[Mapping=tex-text,ItalicFeatures={Contextuals={NoLineInitial,NoLineFinal}}]{Hoefler Text}
\setsansfont[Mapping=tex-text]{Gill Sans}
\setmonofont[Scale=0.85]{Menlo Regular}
\setmathsfont(Digits,Latin)[ItalicFeatures={Contextuals={NoLineInitial,NoLineFinal}},Numbers=Lining]{Hoefler Text}
%\setmathsfont(Greek){Georgia}

% use all-bullets for itemize and give them the right size and height
\AtBeginDocument{
\def\labelitemi{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemii{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemiii{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemiv{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
}

% repeat tufte chapter definition because it got garbled by hyperref
\long\def\@caption#1[#2]#3{\par%
\addcontentsline{\csname ext@#1\endcsname}{#1}%
{\protect\numberline{\csname the#1\endcsname}{\ignorespaces #2}}%
\begingroup%
\@parboxrestore%
\if@minipage\@setminipage\fi%
\@tufte@caption@font\@tufte@caption@justification%
\noindent\csname fnum@#1\endcsname: \ignorespaces#3\par%
\endgroup}

% alternative chapter titling with big chapter number on the right
\titleformat{\chapter}[display]
{\relax\ifthenelse{\NOT\boolean{@tufte@symmetric}}{\begin{fullwidth}}{}}
{\hfill\sffamily\color{gray}\fontsize{42}{0}\selectfont\thechapter}
{0pt}
{\vskip -33pt\huge\rmfamily\itshape}
[\ifthenelse{\NOT\boolean{@tufte@symmetric}}{\end{fullwidth}}{}]

% enable colored page edge when a new chapter starts
\newcommand{\chapteredge}{
\fancypagestyle{plain}{
\fancyhf{}
\fancyfoot[LE,RO]{
\begin{picture}(0,0)
\color{gray}
\put(49,-60){\rule{10mm}{305mm}}
\end{picture}
}}}

% simplified title and author for fancy headers, height-correct the dash
\renewcommand{\plaintitle}{Practical Real\raisebox{-0.45mm}{-}Time with Look\raisebox{-0.45mm}{-}Ahead Scheduling}
\renewcommand{\plainauthor}{Michael Roitzsch}

% epigraph command
\newcommand{\epigraph}[2]{
\begin{fullwidth}
\sffamily\large
\begin{doublespace}
\noindent\allcaps{#1}\\% epigraph
\noindent\allcaps{#2}% author
\end{doublespace}
\end{fullwidth}
}
\end_preamble
\options a4paper
\use_default_options true
\begin_modules
fixltx2e
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Style Verleger
Margin	Static
LatexType	Command
Category	FrontMatter
LatexName	publisher
InTitle	1
InPreamble	1
Font
Size	Large
EndFont
End

InsetLayout Flex:AllCaps
CopyStyle AllCaps
End

InsetLayout Flex:SmallCaps
CopyStyle SmallCaps
End
\end_local_layout
\language english
\language_package default
\inputencoding utf8-plain
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Practical Real-Time with Look-Ahead Scheduling"
\pdf_author "Michael Roitzsch"
\pdf_subject "Dissertation"
\pdf_keywords "Real-Time, Multicore, Work Queues, Look-Ahead, Clairvoyance"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 1
\tocdepth 2
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Itemize
Greek letters in math mode are still typeset in computer modern.
 Enabling Georgia as a replacement (see preamble section in document settings)
 hangs 
\family typewriter
xelatex
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
frontmatter
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
null
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
epigraph{For I dipt into the future, far as human eye could see,
\backslash
newline
\backslash
noindent saw the vision of the world, and all the wonder that would be.}{Alfred
 Lord Tennyson}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
This first epigraph feels the most out-of-place of the three.
 Can we find something more software- or technology-related?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
epigraph{The art of prophecy is very difficult,
\backslash
newline
\backslash
noindent especially with respect to the future.}{Mark Twain}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
epigraph{Oh dear! Oh dear! I shall be too late!}{The White Rabbit}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Author
Michael Roitzsch – born August 15, 1980
\end_layout

\begin_layout Title
Practical Real
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
raisebox{0.8mm}{-}
\end_layout

\end_inset

Time
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

with Look
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
raisebox{0.8mm}{-}
\end_layout

\end_inset

Ahead
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Scheduling
\end_layout

\begin_layout Verleger
Dissertation
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Advisor: Prof.
 Dr.
 rer.
 nat.
 Hermann Härtig
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset


\lang ngerman
Technische Universität Dresden
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
null
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset


\begin_inset Graphics
	filename Figures/TU-Logo.pdf
	width 5cm

\end_inset


\end_layout

\begin_layout Full Width

\lang ngerman
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout

\lang ngerman
Dissertation
\end_layout

\end_inset

 zur Erlangung des akademischen Grades 
\begin_inset Flex AllCaps
status collapsed

\begin_layout Plain Layout

\lang ngerman
Doktoringenieur (Dr.-Ing.)
\end_layout

\end_inset

, vorgelegt an der 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout

\lang ngerman
Technischen Universität Dresden, Fakultät Informatik
\end_layout

\end_inset

, eingereicht von 
\begin_inset Flex AllCaps
status collapsed

\begin_layout Plain Layout

\lang ngerman
Dipl.-Inf.
 Michael Roitzsch
\end_layout

\end_inset

, geboren am 15.
 August 1980 in Dresden.
\end_layout

\begin_layout Full Width

\lang ngerman
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt" special="@{}l">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Betreuender Hochschullehrer:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Prof.
 Dr.
 rer.
 nat.
 Hermann Härtig,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Technische Universität Dresden
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Fachreferent:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Prof.
 Dr.
 Christof Fetzer,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Technische Universität Dresden
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Gutachter:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\lang ngerman
fehlt
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Statusvortrag:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
12.
 Dezember 2011
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Tag der Verteidigung:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\lang ngerman
fehlt
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Full Width
\begin_inset VSpace defskip
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset


\lang ngerman
Dresden, 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\lang ngerman
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Acknowledgments
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
OS group, Prof.
 Härtig, fellow researchers, friends, parents
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList margintable

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Full Width
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
null
\end_layout

\end_inset


\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent
\backslash
nohyphenation 
\end_layout

\end_inset


\shape italic
\size huge

\begin_inset Note Greyedout
status open

\begin_layout Plain Layout

\shape italic
\size huge
Dedication
\end_layout

\end_inset


\end_layout

\begin_layout Full Width
\begin_inset VSpace vfill
\end_inset


\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Chapter*
Introduction
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
The computing revolution
\end_layout

\end_inset

 has treated users with an impressive stream of innovation: From the mainframe
 era through the age of productivity computing to today’s multimedia and
 mobile world, the capabilities of systems and thus the possibilities for
 users increased steadily.
 This development has been driven by the exponential improvement of the
 underlying transistor technology as predicted by Moore’s Law: The number
 of transistors that can be integrated cost efficiently doubles approximately
 every two years.
\begin_inset Foot
status open

\begin_layout Plain Layout
This period is often misquoted as 18 months, which has actually been a follow-up
 prediction of the increase in single chip performance.
\end_layout

\end_inset

 This exponential growth is matched by software: The total body of open
 source software in the world doubles about every 14 months.
\begin_inset CommandInset citation
LatexCommand cite
key "Deshpande:GrowthSoftware"

\end_inset


\end_layout

\begin_layout Section*
Developer Burden
\end_layout

\begin_layout Standard
Users have grown accustomed to the constant improvement of the technology.
 High-end expert use cases will become a commodity just a few years later
 and users will expect them to work predictably and efficiently.
 The present-day iPad
\begin_inset space ~
\end_inset

2 would have been in 1994’s Top
\begin_inset space ~
\end_inset

500 list of the fastest computers in the world
\begin_inset CommandInset citation
LatexCommand cite
key "Markoff:DongarraIPad"

\end_inset

 and it is arguably more accessible today than those supercomputers were
 back then.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
Satisfying these user expectations
\end_layout

\end_inset

 is a demanding job for developers.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
these are hard times for developers
\end_layout

\begin_deeper
\begin_layout Itemize
users demand not only functionality, but are now used to quick responsiveness,
 speedy applications and low energy use
\end_layout

\begin_layout Itemize
these are hard problems:
\end_layout

\begin_deeper
\begin_layout Itemize
responsiveness in the face of non-real-time operating system interfaces
\end_layout

\begin_layout Itemize
speed in the face of stagnating single-core frequency and increasing core
 counts
\end_layout

\begin_layout Itemize
load adaptation without global knowledge or fairness
\end_layout

\begin_layout Itemize
energy characteristics typically dictated and managed behind the scenes
 by hardware
\end_layout

\end_deeper
\begin_layout Itemize
some of these goals are at odds: speed vs.
 energy, throughput vs.
 responsiveness
\end_layout

\begin_layout Itemize
developers have to build on top of a good foundation to manage complexity
\end_layout

\end_deeper
\begin_layout Itemize
these are hard times for the scheduler
\end_layout

\begin_deeper
\begin_layout Itemize
schedulers need to provide order that
\end_layout

\begin_deeper
\begin_layout Itemize
fulfills timing requirements
\end_layout

\begin_layout Itemize
efficiently uses cores
\end_layout

\begin_layout Itemize
handles overload gracefully and fairly
\end_layout

\begin_layout Itemize
is energy efficient
\end_layout

\end_deeper
\begin_layout Itemize
schedulers for peripheral devices have more insight into requested work
 than the CPU scheduler
\end_layout

\begin_layout Itemize
pending jobs queue up in scheduler and can be inspected, metadata can be
 attached or derived
\end_layout

\begin_deeper
\begin_layout Itemize
sidetrack problem: devices get increasingly smart, so this view is simplistic
 but still helps to illustrate the difference between scheduling devices
 and CPU
\end_layout

\end_deeper
\begin_layout Itemize
this work is about CPU scheduling, not about device scheduling
\end_layout

\begin_layout Itemize
CPU scheduler typically sees only opaque threads, behavior is hidden inside
 applications
\end_layout

\begin_deeper
\begin_layout Itemize
priorities are a very coarse abstraction that is hard for developers
\end_layout

\begin_layout Itemize
implicit knowledge from periodic tasks only useful for applications that
 fit into that rigid model
\end_layout

\end_deeper
\begin_layout Itemize
CPU scheduler wants ahead-of-time knowledge on timing and resource requirements
\end_layout

\begin_deeper
\begin_layout Itemize
more discussion on existing approaches: see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Real-Time"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
combine both problems and provide an integrated solution
\end_layout

\begin_deeper
\begin_layout Itemize
needs vertical integration to solve problem functionally, horizontal integration
 to curb development complexity
\end_layout

\begin_layout Itemize
targets interactive systems (desktop, notebook, smartphone), not reactive
 systems (industrial control, deeply embedded)
\end_layout

\begin_layout Itemize
pragmatic and manageable for developers
\end_layout

\begin_layout Itemize
sufficient information for scheduler
\end_layout

\begin_layout Itemize
large body of research in these individual topics is available
\end_layout

\end_deeper
\begin_layout Itemize
driving insights
\end_layout

\begin_deeper
\begin_layout Itemize
applications are increasingly structured into work packets: see Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Anatomy"

\end_inset


\end_layout

\begin_layout Itemize
allow applications to expose knowledge of their future execution to provide
 insightful look-ahead for the scheduler
\end_layout

\begin_layout Itemize
allows ahead-of-time decisions rather than post-mortem control
\end_layout

\end_deeper
\begin_layout Itemize
apply this idea to real-time, parallelism, adaptivity and energy, name key
 contributions in each
\end_layout

\begin_deeper
\begin_layout Itemize
end-to-end-solutions must consider three levels: workload, application,
 system
\end_layout

\begin_deeper
\begin_layout Itemize
collaboration between system and application is beneficial
\end_layout

\begin_layout Itemize
combine application-specific knowledge with general mechanism, not either-or
\end_layout

\begin_layout Itemize
table or summary figure with columns/swim lanes for topics and layers for
 levels
\end_layout

\end_deeper
\begin_layout Itemize
real-time scheduling (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Real-Time"

\end_inset

): explicit timing requirements and workload hints to describe resource
 requirements
\end_layout

\begin_deeper
\begin_layout Itemize
contribution: task model and API that is manageable for developers and expressiv
e for EDF scheduling with look-ahead
\end_layout

\begin_layout Itemize
real-time scheduling exploits exposed timing requirement
\end_layout

\begin_layout Itemize
evaluation: fair sharing without timing requirements misses deadlines, workload
 hints provide good estimate for resource requirements
\end_layout

\end_deeper
\begin_layout Itemize
parallel scheduling (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Parallelism"

\end_inset

): load-aware placement of work on cores
\end_layout

\begin_deeper
\begin_layout Itemize
contribution: enhancing API with work packet scaling factor (
\begin_inset Quotes eld
\end_inset

packet width
\begin_inset Quotes erd
\end_inset

) allows to trade core count against completion time
\end_layout

\begin_layout Itemize
placement of parallel work exploits exposed resource requirements
\end_layout

\begin_layout Itemize
evaluation: start more cores only when you know it will not fit (energy
 saving policy)
\end_layout

\end_deeper
\begin_layout Itemize
adaptivity (Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Adaptivity"

\end_inset

): exposing alternative execution paths for graceful handling of overload
\end_layout

\begin_deeper
\begin_layout Itemize
contribution: look-ahead scheduling can mitigate overload before it occurs
\end_layout

\begin_layout Itemize
adaptivity exploits look-ahead
\end_layout

\begin_layout Itemize
evaluation: fallback path for video decoding with application-specific quality
 measure
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
introduce video as the primary demo application
\end_layout

\begin_deeper
\begin_layout Itemize
good sample workload, because it covers many properties: intrinsic deadlines,
 high throughput, parallel, potentially adaptive, subject to energy savings
\end_layout

\begin_layout Itemize
this architecture also covers applications with just a subset of the properties
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Plain Layout
other application to validate claims more comprehensively
\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mainmatter
\backslash
chapteredge
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Anatomy"

\end_inset

Anatomy of a Modern Desktop Application
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
major changes in application structure
\end_layout

\begin_deeper
\begin_layout Itemize
single-threaded
\end_layout

\begin_deeper
\begin_layout Itemize
UI blocks on every user-triggered activity
\end_layout

\begin_layout Itemize
unresponsive, not parallel, but simple code
\end_layout

\end_deeper
\begin_layout Itemize
multithreaded
\end_layout

\begin_deeper
\begin_layout Itemize
focus on responsiveness, do long-running work asynchronously off the UI
 thread
\end_layout

\begin_layout Itemize
threading is necessary, but not sufficient for concurrency: we saw that
 when moving to multicores
\end_layout

\begin_layout Itemize
explicit thread management with hard-coded or guessed thread count
\end_layout

\begin_layout Itemize
difficult code
\end_layout

\end_deeper
\begin_layout Itemize
today: work packets
\end_layout

\begin_deeper
\begin_layout Itemize
the UI thread (main thread) does no real work (see microkernel paradigm),
 it merely dispatches (spine-analogy) to keep background workers busy
\end_layout

\begin_layout Itemize
similar to networks moving from switched circuits to packet routing
\end_layout

\begin_layout Itemize
analogy: packet-switching in the phone network, railway trains on a track
 network
\begin_inset CommandInset citation
LatexCommand cite
key "MacResearch:AboardGrandCentral"

\end_inset


\end_layout

\begin_layout Itemize
work set model
\begin_inset CommandInset citation
LatexCommand cite
key "Kulkarni:Galois"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
executing some work packets can add new work packets to the set
\end_layout

\begin_layout Itemize
useful to implement irregular algorithms (processing on graph-like data
 structures with pointers, opposite: dense array)
\end_layout

\end_deeper
\begin_layout Itemize
set down the terminology here: 
\begin_inset Quotes eld
\end_inset

work packets
\begin_inset Quotes erd
\end_inset

 or just 
\begin_inset Quotes eld
\end_inset

work
\begin_inset Quotes erd
\end_inset

 to denote those items of code+state
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
implementations of work packet programming
\end_layout

\begin_deeper
\begin_layout Itemize
lambdas/closures/blocks/tasks/activities as useful abstraction for declaring
 a piece of work inline: code looks serial, logical locality
\end_layout

\begin_layout Itemize
Microsoft: 
\begin_inset Formula $\lambda$
\end_inset

-functions turn out to be the holy-grail feature
\begin_inset CommandInset citation
LatexCommand cite
key "Sutter:C++AMP_Keynote"

\end_inset

 for developing the parallel patterns library as a library
\end_layout

\begin_layout Itemize
four aspects: logical coherence, automatic state capture, asynchronous invocatio
n, automatic thread management
\end_layout

\begin_layout Itemize
closures solve the first two, work queues the other two
\end_layout

\begin_deeper
\begin_layout Itemize
keep pending packets, automatic thread assignment and pooling, system-wide
 thread balancing
\end_layout

\begin_layout Itemize
thread count becomes controllable
\end_layout

\begin_layout Itemize
goal: have the number of active threads match the number of (logical) cores
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:SchedulerActivations"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
do a table with checkmarks comparing different implementations of the paradigm
\end_layout

\begin_deeper
\begin_layout Itemize
Apple GCD, Microsoft PPL
\begin_inset CommandInset citation
LatexCommand cite
key "MSDN:C++PPL"

\end_inset

, X10
\begin_inset CommandInset citation
LatexCommand cite
key "Charles:X10"

\end_inset

: all four
\end_layout

\begin_layout Itemize
cross-thread signal-slot-connections in Qt
\begin_inset CommandInset citation
LatexCommand cite
key "Qt:SignalsSlotsThreads"

\end_inset

: asynchronous method calls, no automatic thread management, no automatic
 state-capturing
\end_layout

\begin_layout Itemize
Go-routines in Google Go: asynchronous method calls, automatic thread management
, no automatic state-capturing
\end_layout

\begin_layout Itemize
TaskC model for Core Manager
\begin_inset CommandInset citation
LatexCommand cite
key "Arnold:TaskC"

\end_inset

: asynchronous task spawning but not nested, automatic placement decision,
 manual statue capture because its not shared memory
\end_layout

\begin_layout Itemize
OpenMP for regular algorithms like iterating over dense arrays, mostly paralleli
zing loops: automatic thread assignment, guided self-scheduling to reduce
 dispatching overhead, synchronous
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
result of this architecture: most work is done asynchronously and is announced
 by the before execution
\end_layout

\begin_deeper
\begin_layout Itemize
limited view into the future as a common trait for modern applications (this
 is a key point here)
\end_layout

\begin_layout Itemize
describe fundamental video player architecture
\end_layout

\begin_layout Itemize
work packets (or groups of them) are natural receivers for metadata by the
 developer (deadlines) or automatically by the system (training)
\end_layout

\begin_layout Itemize
this thesis: apply concept to real-time, parallel scheduling, adaptivity,
 energy
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Real-Time"

\end_inset

Real Simple Real
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
raisebox{-0.45mm}{-}
\end_layout

\end_inset

Time
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
many applications have intrinsic real-time characteristics
\end_layout

\begin_deeper
\begin_layout Itemize
real-time naturally surfaces when computers interact with the real world,
 in both input and output
\end_layout

\begin_layout Itemize
all desktops do that, yet almost no desktop software uses real-time programming
\end_layout

\begin_layout Itemize
deadlines for UI code driven by usability requirements: 10/100/1000
\begin_inset space \thinspace{}
\end_inset

ms
\end_layout

\begin_layout Itemize
obvious for animations, which become increasingly ubiquitous and which should
 not stutter if they are supposed to help usability by supporting mental
 transitions
\end_layout

\begin_layout Itemize
even harder for touch-based interaction, where lag of UI breaks the user's
 mental link of interacting with on-screen items directly
\end_layout

\begin_layout Itemize
often buried within the application and not expressed
\end_layout

\begin_layout Itemize
real-time used to be a rare special case, but it should become default;
 this work tries to pave the way
\end_layout

\end_deeper
\begin_layout Itemize
real-time scheduling is about ordering work so that it meets timing requirements
\end_layout

\begin_deeper
\begin_layout Itemize
order matters with time
\end_layout

\begin_layout Itemize
how to communicate timing and resource requirements between application
 and scheduler?
\end_layout

\begin_layout Itemize
existing solutions: spectrum between strong guarantees + complex programming
 and weak guarantees + simple programming
\end_layout

\begin_deeper
\begin_layout Itemize
points in this design space discussed in related work, here: only the ends
\end_layout

\end_deeper
\begin_layout Itemize
one end: classical periodic task model
\end_layout

\begin_deeper
\begin_layout Itemize
inflexible way to express timing requirements, pessimistic resource requirements
\end_layout

\begin_layout Itemize
fixed share of the CPU set aside
\end_layout

\begin_layout Itemize
for video: worst-case planning leads to infeasible reservation way off the
 actual demand
\end_layout

\begin_layout Itemize
however, the advantage: infinite clairvoyance allows an admission test
\end_layout

\begin_layout Itemize
strict admission not useful on desktops: yet another error condition for
 the developer, how to communicate refusal to the user?
\end_layout

\end_deeper
\begin_layout Itemize
other end: fair CPU sharing
\end_layout

\begin_deeper
\begin_layout Itemize
nothing to be done for developers, but also: nothing can be done
\end_layout

\begin_layout Itemize
scheduler distributes CPU evenly across applications according to a fairness
 measure
\end_layout

\begin_layout Itemize
Android: all Dalvik threads use SCHED_OTHER
\begin_inset CommandInset citation
LatexCommand cite
key "Maia:AndroidRT"

\end_inset


\end_layout

\begin_layout Itemize
applications treated equally, disregarding their timing requirements because
 they are not expressed
\end_layout

\begin_layout Itemize
for video: heavy calculation constricts video
\end_layout

\begin_layout Itemize
priorities would fix this, but they are an implementation detail of the
 scheduler that is hard to determine for developers in open systems
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
find a good middle ground between both approaches
\end_layout

\begin_deeper
\begin_layout Itemize
express timing requirements, but more flexible than periodic task: deadlines
\end_layout

\begin_layout Itemize
this is an attribute within the application's problem domain
\end_layout

\begin_deeper
\begin_layout Itemize
system cannot guess it
\end_layout

\begin_layout Itemize
developers should be able to provide it
\end_layout

\end_deeper
\begin_layout Itemize
express resource requirements, but without asking for execution times, which
 are hardware-dependent
\end_layout

\begin_layout Itemize
replace full clairvoyance with limited look-ahead
\end_layout

\end_deeper
\begin_layout Itemize
deriving architecture from requirements
\end_layout

\begin_deeper
\begin_layout Itemize
execution time is workload-dependent, deadlines are application-specific:
 application-view needed
\end_layout

\begin_layout Itemize
scheduling must distribute all loads across all compute resources: global
 view needed
\end_layout

\begin_layout Itemize
application-level component and global scheduler must work together
\end_layout

\end_deeper
\begin_layout Itemize
look-ahead
\end_layout

\begin_deeper
\begin_layout Itemize
for autonomous computing tasks, applications already know what lies ahead
\end_layout

\begin_deeper
\begin_layout Itemize
only code and data determine the upcoming computation, both are known ahead-of-t
ime
\end_layout

\begin_layout Itemize
counterexample: direct, low-latency reaction to user input
\end_layout

\end_deeper
\begin_layout Itemize
given the asynchronous execution model discussed above, this future execution
 can be exposed as real-time jobs early
\end_layout

\begin_deeper
\begin_layout Itemize
explain video player architecture with buffers and work submission (see
 status talk)
\end_layout

\begin_layout Itemize
individual work packets may be too fine-grained
\end_layout

\begin_deeper
\begin_layout Itemize
model jobs as groups of work packets
\end_layout

\begin_layout Itemize
attach deadlines there
\end_layout

\begin_layout Itemize
GCD supports those
\end_layout

\end_deeper
\begin_layout Itemize
must stay within application domain
\end_layout

\begin_layout Itemize
hints are needed to predict execution times
\end_layout

\end_deeper
\begin_layout Itemize
use this knowledge to provide insightful clairvoyance
\end_layout

\begin_layout Itemize
previous work usually depends on black-box guessing and post-mortem control
\end_layout

\begin_deeper
\begin_layout Itemize
state the key advancement here and forward-reference to the full related
 work discussion
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
end-to-end solution
\end_layout

\begin_deeper
\begin_layout Itemize
workload: analyze dependency between data and execution time – execution
 time metrics for video
\begin_inset CommandInset citation
LatexCommand cite
key "roitzsch06:predict"

\end_inset


\end_layout

\begin_layout Itemize
application: offer look into the future, derive execution time prediction
 from hints, attach deadlines to jobs, propagate knowledge down to system
 level
\end_layout

\begin_layout Itemize
system: insert all jobs in an EDF run queue
\end_layout

\end_deeper
\begin_layout Itemize
explain online execution time training in detail
\end_layout

\begin_deeper
\begin_layout Itemize
evaluate accuracy of execution time prediction against worst-case allocation
 of a periodic task
\end_layout

\end_deeper
\begin_layout Itemize
system scheduler
\end_layout

\begin_deeper
\begin_layout Itemize
work packet programming model not compatible with fixed task priorities
\end_layout

\begin_deeper
\begin_layout Itemize
the same thread might execute work of different urgency
\end_layout

\begin_layout Itemize
depends on what work the application dispatches when to what queue
\end_layout

\begin_layout Itemize
we could restrict the programmer to allow for more implicit scheduler knowledge
 (like minimum inter-arrival distance), but this work opts not to
\end_layout

\begin_layout Itemize
the urgency of one job remains the same over its lifetime
\end_layout

\begin_layout Itemize
we need dynamic task priorities, but have fixed job priorities, so G-EDF
 is a natural choice
\end_layout

\end_deeper
\begin_layout Itemize
G-EDF is optimal for soft real-time
\begin_inset CommandInset citation
LatexCommand cite
key "Devi:GEDFTardiness"

\end_inset


\end_layout

\begin_layout Itemize
useful bounded tardiness characteristics: allows unrealistic deadlines,
 like 0 for low latency 
\begin_inset Quotes eld
\end_inset

right now
\begin_inset Quotes erd
\end_inset

 work
\end_layout

\begin_deeper
\begin_layout Itemize
however: unbounded deadline misses under overload
\end_layout

\end_deeper
\begin_layout Itemize
use infinite deadline for best effort background activity
\end_layout

\begin_layout Itemize
break ties in round-robin fashion
\end_layout

\begin_layout Itemize
efficient EDF implementation strategies are known for single cores
\begin_inset CommandInset citation
LatexCommand cite
key "Short:EDFTaskManagement"

\end_inset

 and extensive studies for multicores
\begin_inset CommandInset citation
LatexCommand cite
key "Brandenburg:GlobalEDF"

\end_inset


\end_layout

\begin_layout Itemize
G-EDF scales for today's core counts, in the future we may want to consider
 clustered scheduling
\begin_inset CommandInset citation
LatexCommand cite
key "Calandrino:ClusteredEDF"

\end_inset


\end_layout

\begin_layout Itemize
ongoing discussion on trading schedulability and locality using partitioning,
 clustering
\begin_inset CommandInset citation
LatexCommand cite
key "Bastoni:EmpiricalComparison"

\end_inset

 and semi-partitioning
\begin_inset CommandInset citation
LatexCommand cite
key "Bastoni:SemiPartitioned"

\end_inset

 (some tasks allowed to migrate)
\end_layout

\begin_layout Itemize
evaluate my EDF scheduler overhead
\end_layout

\end_deeper
\begin_layout Itemize
end-to-end evaluation
\end_layout

\begin_deeper
\begin_layout Itemize
timeliness against a fair share scheduler
\end_layout

\end_deeper
\begin_layout Itemize
discuss related work in detail
\end_layout

\begin_deeper
\begin_layout Itemize
explore the spectrum introduced above, compare approaches to describe timing
 and resource requirements
\end_layout

\begin_layout Itemize
periodic tasks with probabilistic admission
\begin_inset CommandInset citation
LatexCommand cite
key "Hamann:QAS,Hamann:QRMS"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
more flexible resource requirements than strict periodic tasks, probabilistic
 admission
\end_layout

\begin_layout Itemize
higher utilization, but still using period for timing requirements
\end_layout

\begin_layout Itemize
QRMS runs on top of fixed priority scheduling
\end_layout

\end_deeper
\begin_layout Itemize
fixed priority systems
\end_layout

\begin_deeper
\begin_layout Itemize
expose scheduler implementation to userland, other task models would be
 implemented on top
\end_layout

\begin_layout Itemize
microkernel paradigm
\end_layout

\begin_layout Itemize
used in practice: QNX in the BlackBerry PlayBook
\end_layout

\end_deeper
\begin_layout Itemize
RT in Linux
\end_layout

\begin_deeper
\begin_layout Itemize
SCHED_RR, SCHED_FIFO
\end_layout

\begin_layout Itemize
RT-patch adds SCHED_DEADLINE
\end_layout

\begin_layout Itemize
only for root processes
\end_layout

\end_deeper
\begin_layout Itemize
time-constrained threads
\end_layout

\begin_deeper
\begin_layout Itemize
periodic thread with an average and maximum execution time
\end_layout

\begin_layout Itemize
accessible for non-root processes
\end_layout

\begin_layout Itemize
vague demotion policy to prevent denial of service
\end_layout

\begin_layout Itemize
execution time provided directly
\end_layout

\end_deeper
\begin_layout Itemize
task models that express other properties: gravitational task model
\end_layout

\begin_layout Itemize
two-level scheduling
\begin_inset CommandInset citation
LatexCommand cite
key "Shin:Compositional"

\end_inset


\end_layout

\begin_layout Itemize
integration of hard real-time, soft real-time and best effort: RBED
\begin_inset CommandInset citation
LatexCommand cite
key "Brandt:RBED"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
focus in integration while preserving strong guarantees
\end_layout

\begin_layout Itemize
underlying hard real-time EDF scheduler, resource allocator on top protects
 EDF scheduler from overload
\end_layout

\begin_layout Itemize
key insight: separate resource management from resource dispatching
\end_layout

\begin_layout Itemize
starts with periodic task model and calculates relaxation bounds for parameters
 that keep the schedule feasible
\end_layout

\begin_layout Itemize
applications can submit jobs with parameters within those bounds
\end_layout

\begin_layout Itemize
set_rbed_scheduler() and rbed_deadline_met() calls similar to submit/next
\end_layout

\end_deeper
\begin_layout Itemize
Constant Bandwidth Server
\begin_inset CommandInset citation
LatexCommand cite
key "Abeni:CBS"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
also employs EDF as the fundamental scheduler
\end_layout

\begin_layout Itemize
provides temporal isolation: protect hard real-time tasks from the messy
 soft real-time tasks
\end_layout

\begin_layout Itemize
server manages the deadlines (assignment, postponing), not the application
\end_layout

\begin_layout Itemize
does not target improving the soft-real time workload, thus somewhat orthogonal
 to this work
\end_layout

\begin_layout Itemize
could be used to provide isolated hard real-time load in our system
\end_layout

\end_deeper
\begin_layout Itemize
reservation-based approaches
\begin_inset CommandInset citation
LatexCommand cite
key "Abeni:AdaptiveReservations"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
similarities: no worst-case planning, because it is wasteful; no focus on
 preventing every single deadline violation
\end_layout

\begin_deeper
\begin_layout Itemize
overload handling instead of admission
\end_layout

\begin_layout Itemize
two layer approach: dedicated controller per task like HDE
\end_layout

\end_deeper
\begin_layout Itemize
different world view: illusion of a dedicated slower processor
\end_layout

\begin_deeper
\begin_layout Itemize
fluid flow allocation contradicts the work packet style, more amenable to
 threads
\end_layout

\end_deeper
\begin_layout Itemize
dynamic bandwidth adaptation to workflow as an afterthought
\end_layout

\begin_deeper
\begin_layout Itemize
black-box control vs.
 insightful cooperation using hints
\end_layout

\begin_layout Itemize
my predictor can be used in a reservation-based system
\end_layout

\begin_layout Itemize
still: post-mortem adaptation vs.
 look-ahead
\end_layout

\end_deeper
\begin_layout Itemize
finishing work until the deadline matters, abstracting from the application's
 work pattern using reservations makes this harder to accomplish and requires
 more complexity in control layer
\end_layout

\begin_deeper
\begin_layout Itemize
slack reclaiming added
\begin_inset CommandInset citation
LatexCommand cite
key "Palopoli:FeedbackReclaiming"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
gratuitously applying control theory might cover up the real interactions
 of components and tries to recreate them in another layer
\end_layout

\end_deeper
\begin_layout Itemize
Self-tuning scheduler
\begin_inset CommandInset citation
LatexCommand cite
key "Cucinotta:Self-Tuning"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
treat existing real-time application as black box: 
\begin_inset Quotes eld
\end_inset

applications that are characterized by some temporal constraints, but are
 not developed using a specific API
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
insight: applications have real-time behavior but do not expose it, I modify
 applications and allow them to expose this
\end_layout

\begin_layout Itemize
estimate period and execution time by looking at its outside behavior
\end_layout

\begin_layout Itemize
study in this paper: choosing the wrong scheduling period causes deadline
 misses or over-allocation, so schedulers that decouple scheduling period
 from application period can be inefficient
\end_layout

\end_deeper
\begin_layout Itemize
Redline
\begin_inset CommandInset citation
LatexCommand cite
key "Yang:Redline"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Redline Slides"
target "http://os.inf.tu-dresden.de/local/dropscon/archive/2008-12-03-Michael-Redline.pdf"

\end_inset


\end_layout

\begin_layout Itemize
also no modifications to applications
\end_layout

\begin_layout Itemize
manual annotation with period and fixed execution time
\end_layout

\begin_layout Itemize
will adapt parameters at runtime using feedback
\end_layout

\begin_layout Itemize
uses EDF scheduler
\end_layout

\end_deeper
\begin_layout Itemize
coop_poll
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:CoopPoll"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
uses application insight, no black-box approach, applications explicitly
 expose knowledge
\end_layout

\begin_layout Itemize
propagates application's task descriptions down to the kernel, but without
 look-ahead
\end_layout

\end_deeper
\begin_layout Itemize
device IO
\end_layout

\begin_deeper
\begin_layout Itemize
propagate deadlines to device queues when jobs issue IO requests
\end_layout

\begin_layout Itemize
GCD fosters asynchronous device access and queue-ahead of upcoming jobs:
 provides the same look-ahead for device IO
\end_layout

\begin_layout Itemize
devices become smart and self-schedule: manage the queue themselves
\end_layout

\begin_deeper
\begin_layout Itemize
example: interrupt rate limiting, low-latency packet override and another
 rate limiting for the low-latency override in Intel 82576 network card
\begin_inset CommandInset citation
LatexCommand cite
key "Intel_NIC"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Dynamic Active Subset helps
\begin_inset CommandInset citation
LatexCommand cite
key "Reuther:DAS"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ARTIFACT
\begin_inset CommandInset citation
LatexCommand cite
key "Sasinowski:ARTIFACT"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
ubiquitous priorities, MPEG execution model hard, load-shedding (forward
 reference to adaptivity)
\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Parallelism"

\end_inset

Scheduling meets Multicore
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
multicores add another scheduling dimension: placement in space accompanies
 ordering in time
\end_layout

\begin_layout Itemize
scheduling in time is being deemphasized
\end_layout

\begin_deeper
\begin_layout Itemize
context switching used to be practical when many threads needed to be multiplexe
d in quasi-parallel fashion on one CPU
\end_layout

\begin_layout Itemize
with the number of cores approaching the number of ready threads, this approach
 gets impractical
\end_layout

\begin_layout Itemize
micro-benchmarks show cache-miss-related slowdown caused by only the timer
 tick
\begin_inset CommandInset citation
LatexCommand cite
key "Tsafrir:OSNoise"

\end_inset


\end_layout

\begin_layout Itemize
hardware transactional memory aborts on context switch
\begin_inset CommandInset citation
LatexCommand cite
key "AMD_ASF_Spec"

\end_inset


\end_layout

\begin_layout Itemize
many other resources cannot be preempted at all
\end_layout

\begin_deeper
\begin_layout Itemize
disk jobs
\end_layout

\begin_layout Itemize
GPUs get preemption functionality, but there is a lot of state to save and
 restore
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
systems increasingly schedule in space instead of time
\end_layout

\begin_deeper
\begin_layout Itemize
parallelism is replacing frequency scaling as the means to increase performance
\end_layout

\begin_layout Itemize
Lampson predicted this
\begin_inset CommandInset citation
LatexCommand cite
key "Lampson:HintsDesign"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

split resources in a fixed way if in doubt, rather than sharing them
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
multiplex as long as hardware is expensive, statically assign once hardware
 is cheap
\end_layout

\end_deeper
\begin_layout Itemize
specialize cores dynamically to execute kernel services
\end_layout

\begin_layout Itemize
shutting down cores is also an important mechanism to save energy, because
 DVFS is losing effectiveness
\begin_inset CommandInset citation
LatexCommand cite
key "LeSueur:DVFS"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
work queues that are drained asynchronously support this well
\end_layout

\begin_deeper
\begin_layout Itemize
queues just offer parallelism, dispatching is separate, system can decide
 placement; threads blend this in one concept
\end_layout

\begin_layout Itemize
number of threads becomes controllable instead of being fixed in the application
 code
\end_layout

\begin_layout Itemize
work queues used within applications and also down to the kernel
\begin_inset CommandInset citation
LatexCommand cite
key "Soares:FlexSC"

\end_inset


\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/Queues_Mode_Switches.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Work queues prevent mode switches.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
improves throughput and (surprisingly) also latency when loaded
\end_layout

\begin_layout Itemize
extends the spine+workers programming model to workloads where the kernel
 is the worker (i.e.
 Internet servers)
\end_layout

\begin_layout Itemize
notifications from kernel to user space could work asynchronously, but don't
 as far as I know, closest: kqueue
\begin_inset CommandInset citation
LatexCommand cite
key "Lemon:Kqueue"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
DSI on L4 provides asynchronous data movement between different address
 spaces
\end_layout

\begin_layout Itemize
many throughput-oriented drivers (network cards) work this way, too
\end_layout

\begin_layout Itemize
work queues also used to drive GPUs predictably
\begin_inset CommandInset citation
LatexCommand cite
key "Kato:Timegraph"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Tetris
\begin_inset Quotes erd
\end_inset

 style scheduling: we want to know the widths and heights of work packets
 to plan placement and order
\end_layout

\begin_deeper
\begin_layout Itemize
prerequisite to implementing placement policies is sufficient information
 on what you place
\end_layout

\begin_layout Itemize
using asynchronous blocks for parallelism and deadlines and hints attached
 to block groups for real-time, both are decoupled
\end_layout

\begin_layout Itemize
execution time estimates give us the total execution time, but when spread
 across cores, it might take less wall-clock time to finish
\end_layout

\begin_layout Itemize
how much less (i.e.
 the parallel efficiency) and how much parallelism can be offered (i.e.
 the parallel degree) should be provided by the application or observed
 by the runtime
\end_layout

\end_deeper
\begin_layout Itemize
end-to-end solution
\end_layout

\begin_deeper
\begin_layout Itemize
workload: make amenable for data-parallel processing like intrinsic load-balanci
ng
\begin_inset CommandInset citation
LatexCommand cite
key "roitzsch07:balancing"

\end_inset


\end_layout

\begin_layout Itemize
application: offer parallelism to the system, provide estimates on parallel
 degree and efficiency
\end_layout

\begin_layout Itemize
system: place jobs on cores and order in time based on deadlines, execution
 time estimates and parallelism
\end_layout

\end_deeper
\begin_layout Itemize
describe parallel workload and placement algorithm in detail
\end_layout

\begin_deeper
\begin_layout Itemize
video parallelization and balancing
\end_layout

\begin_layout Itemize
system communicates consequences of placement decision back to the application
\end_layout

\begin_deeper
\begin_layout Itemize
number of threads to be used by GCD runtime
\end_layout

\begin_layout Itemize
avoid context-switch, so no upcall interface, but info-page-style shared
 memory
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
end-to-end evaluation
\end_layout

\begin_deeper
\begin_layout Itemize
place work on one core as long as it fits, fire up second core only when
 necessary
\end_layout

\end_deeper
\begin_layout Itemize
discuss related work in detail
\end_layout

\begin_deeper
\begin_layout Itemize
schedule in space instead of in time
\end_layout

\begin_deeper
\begin_layout Itemize
OS design for systems with 1000+ cores focus on space sharing instead of
 time sharing
\begin_inset CommandInset citation
LatexCommand cite
key "Wentzlaff:fos"

\end_inset


\end_layout

\begin_layout Itemize
even stronger separation between cores: explicit communication instead of
 cache coherent shared memory
\begin_inset CommandInset citation
LatexCommand cite
key "Baumann:Barrelfish"

\end_inset


\end_layout

\begin_layout Itemize
run parts of the system close or on the device they target
\begin_inset CommandInset citation
LatexCommand cite
key "Nightingale:Helios"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
existing placement strategies can augment our placement algorithm
\end_layout

\begin_deeper
\begin_layout Itemize
fits well with our programming model of applications exposing metadata on
 parallel work
\end_layout

\begin_layout Itemize
performance counters often used for runtime monitoring, like online cache
 utility modeling
\begin_inset CommandInset citation
LatexCommand cite
key "West:CacheUtility"

\end_inset


\end_layout

\begin_layout Itemize
placement of jobs on cores influences contention on caches, prefetcher and
 DRAM controller
\begin_inset CommandInset citation
LatexCommand cite
key "Zhuravlev:DIO"

\end_inset


\end_layout

\begin_layout Itemize
on NUMA-systems, placement influences memory latency
\begin_inset CommandInset citation
LatexCommand cite
key "Blagodurov:DINO"

\end_inset


\end_layout

\begin_layout Itemize
batch work by moving it around in the scheduling window to enable longer
 sleep times
\begin_inset CommandInset citation
LatexCommand cite
key "Awan:EnhancedRaceToHalt"

\end_inset


\end_layout

\begin_layout Itemize
migrate to prevent fan noise or throttling
\begin_inset CommandInset citation
LatexCommand cite
key "Merkel:EnergyModel"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
the execution order of blocks within a job is relevant for speed and cache
 working set size
\begin_inset CommandInset citation
LatexCommand cite
key "Chen:ConstructiveCacheSharing"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
use a lightweight specification language to describe beneficial scheduling
 policies
\begin_inset CommandInset citation
LatexCommand cite
key "Nguyen:ConcurrentSchedulers"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
knowledge about the job layout in both space and time allows disabling the
 periodic timer tick
\end_layout

\begin_deeper
\begin_layout Itemize
dynamically dedicate cores: place work somewhere, then let it run without
 interference
\end_layout

\begin_deeper
\begin_layout Itemize
the timer-tick is OS-level polling, hits all cores no matter what they run
\end_layout

\begin_layout Itemize
move to a tick-less kernels helps to reducing OS noise and energy consumption
\end_layout

\end_deeper
\begin_layout Itemize
good for barrier-sync-style HPC applications: even the timer interrupt hurts
 them badly
\begin_inset CommandInset citation
LatexCommand cite
key "Tsafrir:OSNoise"

\end_inset


\end_layout

\begin_layout Itemize
suggested solution: demand-driven 
\begin_inset Quotes eld
\end_inset

smart
\begin_inset Quotes erd
\end_inset

 timers which allow for batching instead of the slavish periodic tick
\end_layout

\begin_deeper
\begin_layout Itemize
idea is an extension to timers with precision
\begin_inset CommandInset citation
LatexCommand cite
key "Peter:30Seconds"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
hardware extensions supporting work queues and reduced context switching
\end_layout

\begin_deeper
\begin_layout Itemize
NVIDIA Fermi uses GigaThread hardware to decide placement
\begin_inset CommandInset citation
LatexCommand cite
key "NVIDIA_Fermi"

\end_inset


\end_layout

\begin_layout Itemize
Core Manager distributes work and its data to processing elements
\begin_inset CommandInset citation
LatexCommand cite
key "Limberg:Tomahawk"

\end_inset


\end_layout

\begin_layout Itemize
Asynchronous Direct Messages
\begin_inset CommandInset citation
LatexCommand cite
key "Sanchez:ADM"

\end_inset

 allow very fine-grained work packets
\end_layout

\begin_deeper
\begin_layout Itemize
more flexible: small hardware extension to be used by work queue implementation
\end_layout

\begin_layout Itemize
allows exposing more parallelism by splitting into smaller work packets
\end_layout

\begin_layout Itemize
scalable because of local queues and work stealing that bypasses the memory
 hierarchy
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
holistic approach that extends placement problems beyond individual computers
 to distributed systems: MOSIX
\end_layout

\begin_deeper
\begin_layout Itemize
load balancing on networks of computers, predicts future problems within
 manycores
\end_layout

\begin_layout Itemize
increasing message latency between cores relative to compute speed: placement
 of work and communication patterns relevant
\end_layout

\begin_layout Itemize
employs gossiping to establish global system view without a central authority
\end_layout

\begin_layout Itemize
ad-hoc solution for my approach: assume that work packets of the same job
 are more likely to talk to each other, place closer together
\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:Adaptivity"

\end_inset

Adapt to Handle Overload
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
our 
\begin_inset Quotes eld
\end_inset

no admission
\begin_inset Quotes erd
\end_inset

 policy requires us to deal with overloads when the work does not fit within
 the deadlines
\end_layout

\begin_layout Itemize
load shedding is an old concept
\begin_inset CommandInset citation
LatexCommand cite
key "Lampson:HintsDesign"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

shed load to control demand, rather than allowing the system to become overloade
d.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Robert Morris idea: red button next to terminal, push when dissatisfied,
 system must raise your QoS or throw you off
\end_layout

\begin_layout Itemize
this old idea already argued for quality-aware adaptation, not just load-aware
\end_layout

\begin_layout Itemize
when overloaded, real-time applications become brittle and show bi-modal
 fairness
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:PriorityProgress"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
quality-aware adaptation is application-specific
\end_layout

\begin_deeper
\begin_layout Itemize
some work just needs to be done, no discussion, no adaptation possible
\end_layout

\begin_deeper
\begin_layout Itemize
I would argue this is the common case
\end_layout

\begin_layout Itemize
we can only hope to compensate by using the most efficient compute resource
 and organize it the most efficient way
\end_layout

\end_deeper
\begin_layout Itemize
some applications can make quality/resource trade-offs according to application-
specific notion of quality
\end_layout

\begin_deeper
\begin_layout Itemize
video is one example
\end_layout

\begin_layout Itemize
this also applies to resources other than CPU time, like network bandwidth
 for streaming
\end_layout

\end_deeper
\begin_layout Itemize
look-ahead enables choosing the part to degrade amongst many options, compared
 to forcibly degrade the job at hand
\end_layout

\end_deeper
\begin_layout Itemize
end-to-end solution
\end_layout

\begin_deeper
\begin_layout Itemize
workload: offer different processing paths, trading resources and quality
\end_layout

\begin_layout Itemize
application: under given resource constraints, find a quality-optimal path
 through this lattice of options
\end_layout

\begin_layout Itemize
system: distribute computing resource cutbacks in a quality-fair fashion
\end_layout

\end_deeper
\begin_layout Itemize
describe fallback decoding path for video
\begin_inset CommandInset citation
LatexCommand cite
key "roitzsch08:videoquality"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
decoding time estimate already given, quality estimate needed
\end_layout

\begin_layout Itemize
greedy solution for (constrained) bin-packing: order jobs by quality/resource
 ratio
\end_layout

\end_deeper
\begin_layout Itemize
backpressure needs to be quality-fair, not resource-fair, but the quality
 scale is application specific and does not compare
\end_layout

\begin_deeper
\begin_layout Itemize
global quality-scheduling too complex, resort to balanced backpressure and
 per-application adaptivity
\end_layout

\begin_layout Itemize
needs help from the applications: provide percentage of missed deadlines
 relative to the maximum quality case, that represents the bare minimum
 quality users will accept
\end_layout

\begin_layout Itemize
backpressure will be distributed amongst adaptive applications weighted
 by this minimum quality
\end_layout

\begin_layout Itemize
assumption: linear quality drop from meeting all deadlines down to that
 percentage
\end_layout

\begin_deeper
\begin_layout Itemize
could also use time-utility functions to optimize
\end_layout

\end_deeper
\begin_layout Itemize
use of percentage of missed deadlines as quality parameter inspired by QRMS
\begin_inset CommandInset citation
LatexCommand cite
key "hamann07:qrms"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
end-to-end evaluation
\end_layout

\begin_deeper
\begin_layout Itemize
compare to ad-hoc adaptation using a low water-mark in the video player
 queue
\end_layout

\begin_layout Itemize
compare to fully clairvoyant oracle that calculates truly quality-optimal
 execution
\end_layout

\end_deeper
\begin_layout Itemize
discuss related work
\end_layout

\begin_deeper
\begin_layout Itemize
load-shedding queues in network servers
\begin_inset CommandInset citation
LatexCommand cite
key "Welsh:SEDA"

\end_inset


\end_layout

\begin_layout Itemize
overload handling with adaptive reservations
\begin_inset CommandInset citation
LatexCommand cite
key "Abeni:AdaptiveReservations"

\end_inset


\end_layout

\begin_layout Itemize
other sources for adaptive video
\end_layout

\begin_deeper
\begin_layout Itemize
SVC
\end_layout

\begin_layout Itemize
adaptive streaming protocols: application propagates backpressure even to
 the server
\end_layout

\end_deeper
\begin_layout Itemize
prioritize work and skip the low priorities when congested
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:PriorityProgress"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
simple quality-aware scheme
\end_layout

\begin_layout Itemize
global priority-monotonic ordering of video frames
\end_layout

\begin_layout Itemize
unclear how much of the fairness benefits stem from the priority sorting
 or just from global queueing
\end_layout

\end_deeper
\begin_layout Itemize
virtual time for progress fairness
\begin_inset CommandInset citation
LatexCommand cite
key "Krasic:CoopPoll"

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Chapter
The Road Ahead
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Itemize
changing paradigm of computing, future: always on, always connected
\end_layout

\begin_deeper
\begin_layout Itemize
smartphones, tablets and the cloud usher in a new era
\end_layout

\begin_layout Itemize
mobile computing, but still with responsiveness and smooth video demanded
 by users
\end_layout

\begin_layout Itemize
battery and energy constraints added to the problem space
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

energy is the new speed
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
energy works differently
\end_layout

\begin_deeper
\begin_layout Itemize
deadlines are inherent to the application, energy limitations are driven
 by the long-term intent of the user
\end_layout

\begin_layout Itemize
many existing solutions throttle threads according to an energy budget
\begin_inset CommandInset citation
LatexCommand cite
key "Roy:Cinder"

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
not graceful degradation, but just degradation
\end_layout

\end_deeper
\begin_layout Itemize
assuming software does only useful work against the user's stated intent,
 throttling makes no sense
\end_layout

\begin_layout Itemize
only energy efficiency (doing the same with less energy) and maybe adaptivity
 remains
\end_layout

\begin_deeper
\begin_layout Itemize
energy saving by batching is already enabled by look-ahead deadline-knowledge
\end_layout

\begin_layout Itemize
batch network requests to power up radio less often
\begin_inset CommandInset citation
LatexCommand cite
key "Roy:Cinder"

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
we may have targeted hardware with reduced instruction sets available that
 is more energy-efficient
\end_layout

\begin_deeper
\begin_layout Itemize
pieces of GPU code (and other ISAs with tighter assumptions and less ability)
 interwoven with CPU code
\end_layout

\begin_layout Itemize
devices like GPU (and increasingly network cards
\begin_inset CommandInset citation
LatexCommand cite
key "Nightingale:Helios"

\end_inset

) treated as compute resources like CPU, not as a peripheral
\end_layout

\begin_layout Itemize
hardware video decoders as an example of a special-purpose, limited-ISA
 co-processor
\end_layout

\begin_deeper
\begin_layout Itemize
saves some energy (up to 25%
\begin_inset CommandInset citation
LatexCommand cite
key "LeSueur:SlowDownSleep"

\end_inset

), but not game-changing savings
\end_layout

\begin_layout Itemize
treat as any coprocessor that work with tighter restrictions on the available
 instructions can be offloaded to (see 
\family typewriter
restrict
\family default
 keyword proposal
\begin_inset CommandInset citation
LatexCommand cite
key "Sutter:C++AMP_Keynote"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
special-purpose devices offer more choice for job placement and change energy
 tradeoffs, but they do not eliminate the fundamental problem to get given
 work done (meeting given deadlines) with as little resources (energy, time)
 as possible
\end_layout

\begin_layout Itemize
choosing between race-to-halt and slowdown depends on workload and platform
\begin_inset CommandInset citation
LatexCommand cite
key "LeSueur:SlowDownSleep"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
end-to-end solution: this is only a rough sketch
\end_layout

\begin_deeper
\begin_layout Itemize
workload: energy-aware encoding of video
\end_layout

\begin_layout Itemize
we get the three swim lanes again, but with a different metric and intention
\end_layout

\begin_layout Itemize
application: maintain energy model (enhances real-time), code for specialized
 hardware ISA (enables placement), adapt to save energy (enhances adaptivity)
\end_layout

\begin_layout Itemize
system: collect and act on energy metrics (enhances real-time), outsource
 to specialized hardware (enhances placement), backpressure based on energy
 intent (enhances adaptivity)
\end_layout

\end_deeper
\begin_layout Itemize
metadata to decide energy consequences can be collected per-job at runtime
\end_layout

\begin_deeper
\begin_layout Itemize
performance counter can help to tell memory- and CPU-bound jobs apart
\end_layout

\begin_deeper
\begin_layout Itemize
clocking down the CPU especially helpful for memory-bound jobs
\begin_inset CommandInset citation
LatexCommand cite
key "Snowdon:Koala"

\end_inset


\end_layout

\begin_layout Itemize
exploit look-ahead for energy metadata: clock CPU down and then run all
 pending memory-bound jobs
\end_layout

\end_deeper
\begin_layout Itemize
linear combination of metrics to predict energy in a similar way to the
 execution time
\end_layout

\begin_deeper
\begin_layout Itemize
performance counters to train energy model
\begin_inset CommandInset citation
LatexCommand cite
key "Merkel:EnergyModel"

\end_inset


\end_layout

\begin_layout Itemize
energy counter in Intel Sandy Bridge CPUs
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
using backpressure also for energy-management
\end_layout

\begin_deeper
\begin_layout Itemize
some applications can adapt their energy or computation time needs
\begin_inset CommandInset citation
LatexCommand cite
key "Flinn:EnergyAdaptation"

\end_inset


\end_layout

\begin_layout Itemize
trivial examples (disable backup on low battery) are rather obvious and
 not interesting, more dynamic examples are rare
\end_layout

\begin_layout Itemize
use energy instead of CPU time as a cost metric in adaptation decisions
\end_layout

\end_deeper
\begin_layout Itemize
future development can be researched within the presented design
\end_layout

\begin_layout Itemize
summarize the key contributions again
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
backmatter
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setlength{
\backslash
labelwidth}{0mm}
\backslash
setlength{
\backslash
labelsep}{0mm} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Bibliography/Thesis"
options "Bibliography/Thesis"

\end_inset


\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
