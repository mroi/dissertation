#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass tufte-handout
\begin_preamble
% simplified title for fancy headers, height-correct the dash
\renewcommand{\plaintitle}{Practical Real\raisebox{-0.45mm}{-}Time with Look\raisebox{-0.45mm}{-}Ahead Scheduling}

% typesetting tweaks
\clubpenalty=10000
\widowpenalty=10000
\relpenalty=9999
\binoppenalty=9999
\hyphenation{Atlas}
\hyphenation{off-line}

% font setup: disable Hoefler swashes, set math fonts
\usepackage{mathspec}
\setmainfont[ItalicFeatures={Contextuals={NoLineInitial,NoLineFinal}}]{Hoefler Text}
\setmathrm{Hoefler Text}
\setmathsfont(Digits,Latin)[ItalicFeatures={Contextuals={NoLineInitial,NoLineFinal}},Numbers={Lining,Proportional}]{Hoefler Text}
\setmathsfont(Greek){Georgia}
% restore mathspec's activation of " at document beginning, someone messes with it
\begingroup
\catcode`\"=\active
\AtBeginDocument{\let"=\eu@active@quote}
\endgroup

% letter spacing for capitalized text
\renewcommand{\allcapsspacing}[1]{{\addfontfeature{LetterSpace=6.5}#1}}
\renewcommand{\smallcapsspacing}[1]{{\addfontfeature{LetterSpace=5.0,Letters=SmallCaps}#1}}

% lining figures for bibtex references (usually enabled by using math mode)
\newcommand{\liningfigures}[1]{{\addfontfeature{Numbers=Lining}#1}}

% use all-bullets for itemize and give them the right size and height
\AtBeginDocument{
\def\labelitemi{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemii{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemiii{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
\def\labelitemiv{\raisebox{0.3mm}{\scriptsize\(\bullet\)}}
}

% top-align floats on float pages
\setlength\@fptop{0pt}

% repeat tufte caption definition because it gets garbled by hyperref
\long\def\@caption#1[#2]#3{\par%
\addcontentsline{\csname ext@#1\endcsname}{#1}%
{\protect\numberline{\csname the#1\endcsname}{\ignorespaces #2}}%
\begingroup%
\@parboxrestore%
\if@minipage\@setminipage\fi%
\@tufte@caption@font\@tufte@caption@justification%
\noindent\csname fnum@#1\endcsname: \ignorespaces#3\par%
\endgroup}
\end_preamble
\options a4paper
\use_default_options true
\begin_modules
fixltx2e
enumitem
logicalmkup
\end_modules
\maintain_unincluded_children false
\begin_local_layout
InsetLayout Flex:NoWrap
LyxType	charstyle
LabelString	NoWrap
LatexType	Command
LatexName	mbox
HTMLTag	span
HTMLAttr	style='white-space:nowrap'
End
\end_local_layout
\language english
\language_package default
\inputencoding utf8-plain
\fontencoding global
\font_roman Hoefler Text
\font_sans Gill Sans
\font_typewriter Menlo
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 83

\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Practical Real-Time with Look-Ahead Scheduling"
\pdf_author "Michael Roitzsch"
\pdf_subject "Dissertation Summary"
\pdf_keywords "Real-Time, Look-Ahead, Work Queues, Asynchronous Lambdas, Deadlines, Adaptive"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\papersize default
\use_geometry true
\use_amsmath 2
\use_esint 0
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 0
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "aboveskip=0pt,basicstyle={\ttfamily\small},belowskip=0pt,language=C,numberstyle={\ttfamily\small\color{gray}},tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Practical Real-Time with Look-Ahead Scheduling
\end_layout

\begin_layout Author
Michael Roitzsch
\end_layout

\begin_layout Abstract
In my dissertation, I present 
\noun on
Atlas
\noun default

\begin_inset space \thinspace{}
\end_inset

—
\begin_inset space \thinspace{}
\end_inset

the Auto-Training Look-Ahead Scheduler.
 
\noun on
Atlas
\noun default
 improves service to applications with regard to two non-functional properties:
 timeliness and overload detection.
 Timeliness is an important requirement to ensure user interface responsiveness
 and the smoothness of multimedia operations.
 Overload can occur when applications ask for more computation time than
 the machine can offer.
 Interactive systems have to handle overload situations dynamically at runtime.
 
\noun on
Atlas
\noun default
 provides timely service to applications, accessible through an easy-to-use
 interface.
 Deadlines specify timing requirements, workload metrics describe jobs.
 
\noun on
Atlas
\noun default
 employs machine learning to predict job execution times.
 Deadline misses are detected before they occur, so applications can react
 early.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Today’s users are no longer satisfied with functionality alone.
 Increasingly, 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
non-functional properties
\end_layout

\end_inset

 separate good from great applications.
 Such properties include responsive and stutter-free operation,
\begin_inset CommandInset citation
LatexCommand cite
key "MSDN:FastFluid"

\end_inset

 perceived performance, and the useful and efficient employment of the invested
 resources.
 My dissertation is motivated by a need to integrate application knowledge
 with system-wide decision-making to support two essential non-functional
 properties:
\end_layout

\begin_layout Description
Timeliness: Many of today’s applications have intrinsic real-time characteristic
s.
 The term real-time describes a predictable relation between observable
 system behavior and physical time.
\begin_inset CommandInset citation
LatexCommand cite
key "Kopetz:RealTimeSystems"

\end_inset

 Therefore, such requirements naturally surface when computers interact
 with the real world, which most application do through their user interface.
 In this work, I target interactive systems, so examples operating along
 this cyber-physical boundary are timely delivery of system output, such
 as smooth user interface animations or uninterrupted video playback, and
 timely reaction to human input,
\begin_inset CommandInset citation
LatexCommand cite
after "-10pt"
key "Card:RealTimeUI"

\end_inset

 such as classical keyboard and mouse interaction or gesture tracking.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Timing-Requirements"

\end_inset

 illustrates those types of interaction.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset VSpace 0pt
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename Figures/3-Real-Time/Timing_Requirements.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Timing-Requirements"

\end_inset

Sources of Timing Requirements
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Overload
\begin_inset space \space{}
\end_inset

Detection: Real-time systems avoid overload situations statically with an
 admission process: The system will not allow new tasks unless it can establish
 a formal guarantee that the total resource demand will never outgrow the
 available resources.
 Interactive systems give users full control over the system and its load,
 so overload situations must be handled at runtime.
\end_layout

\begin_layout Standard
Non-functional properties such as timeliness and overload handling require
 an integration of local application knowledge with a global system-wide
 policy.
 My mission is to show that a little added developer effort can be augmented
 by a newly designed runtime and lead to closer cooperation with the scheduler,
 enhancing application behavior with respect to those properties.
 I do not explore scheduling on multiple cores in this thesis, but the design
 does not rule it out.
\end_layout

\begin_layout Section
Talking to Schedulers
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset VSpace 20pt
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename Figures/3-Real-Time/Order_Matters.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Order-Matters"

\end_inset

Order Matters
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Real-time scheduling is about ordering work so that its execution meets
 previously negotiated timing constraints.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Order-Matters"

\end_inset

 illustrates that order matters: Two jobs may come with different deadlines
 such that one potential order violates the earlier deadline of job
\begin_inset space ~
\end_inset

B, while another order satisfies both deadlines.
 The scheduler should recognize this advantage of the second ordering and
 pick job
\begin_inset space ~
\end_inset

B first.
 To make this decision, it needs prior knowledge on both jobs’ deadlines
 and execution times.
 The design of the scheduler determines how applications communicate their
 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
timing and resource requirements
\end_layout

\end_inset

 to the system and what guarantees they receive in return.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset VSpace 12pt
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename Figures/3-Real-Time/Solution_Spectrum.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Solution-Spectrum"

\end_inset

Real-Time Solution Spectrum
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
Existing solutions
\end_layout

\end_inset

 cover a spectrum from strictly regulated to loosely managed platforms.
 As depicted in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Solution-Spectrum"

\end_inset

, the strict regulations are harder to program against, but yield strong
 guarantees, whereas the loosely organized systems trade weaker guarantees
 for simpler programming.
 
\noun on
Atlas
\noun default
 wants to strike a balance between the two extremes.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
The classical periodic task model
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Liu:RMS"

\end_inset

 is a strict programming regime, but the system’s runtime behavior will
 be predictable.
 Periodic tasks as illustrated in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Periodic-Task-Model"

\end_inset

 describe a chain of jobs with equal execution time 
\begin_inset Formula $e$
\end_inset

.
 Individual job instances must respect a minimum inter-arrival separation
 time, more commonly referred to as their period 
\begin_inset Formula $p$
\end_inset

.
 Each job meets an implicit deadline at the beginning of the next period,
 so jobs cannot overlap.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/3-Real-Time/Periodic_Task.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Periodic-Task-Model"

\end_inset

Periodic Task Model
\end_layout

\end_inset


\begin_inset VSpace 50pt
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The restrictions of the periodic task model limit application development.
 Complex real-time loads in interactive systems may not easily adhere to
 a minimum inter-arrival distance or a constant execution time of jobs.
 Varying execution times have to be admitted with their theoretical worst
 case, leading to infeasible CPU reservations way higher than the actual
 demand.
 In addition, execution times are hardware dependent and hard to obtain
 for developers.
\end_layout

\begin_layout Standard
The 
\noun on
Atlas
\noun default
 task model should be more flexible.
 Applications should be allowed to place their deadlines arbitrarily and
 job execution times should be flexible.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
Fair CPU sharing
\end_layout

\end_inset

 sits at the simplicity end of the spectrum.
 The Completely Fair Scheduler is the default scheduler on Linux
\begin_inset CommandInset citation
LatexCommand cite
key "Jones:InsideCFS"

\end_inset

.
 The advantage of fair sharing is the lack of a complicated interface or
 task model.
 The scheduler distributes the CPU evenly across all ready threads to ensure
 that all of them make equal progress.
\end_layout

\begin_layout Standard
Users however do not care whether their applications receive equal shares,
 they simply want the right thing to happen at the right time.
 The fair share model is a good abstraction for performance isolation, but
 it may be the wrong abstraction for applications with timing requirements.
 An experiment shows this disadvantage: While playing a representative video
 showing a high definition movie trailer, a competing load of ten CPU-hogging
 processes
\begin_inset Foot
status open

\begin_layout Plain Layout
Their complete source code:
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

int main(void) 
\backslash
{ while (1); 
\backslash
}
\end_layout

\end_inset


\end_layout

\end_inset

 starts one minute into playback.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Video-Smoothness"

\end_inset

 plots the time interval between adjacent frames over the runtime of the
 video, illustrating the user-perceived smoothness of the playback.
 The grey areas mark the competing background activity.
 Ideally, the graph should show a flat line at 
\begin_inset Formula $41.7\,\mathrm{ms}$
\end_inset

, corresponding to a rate of 24 frames per second.
 But as soon as the background load starts, video quality suffers, because
 its timing requirements are no longer satisfied.
 With fair share schedulers, the CPU time available to an application depends
 on the competing load in the system.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/3-Real-Time/Background_CFS.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Video-Smoothness"

\end_inset

Video Smoothness with Competing Background Load
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\noun on
Atlas
\noun default
 should allow applications to specify their timing needs in a way that requires
 no contextual knowledge of the surrounding system.
 
\noun on
Atlas
\noun default
 should meet those timing requirements even at the expense of fairness.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
I evaluate
\end_layout

\end_inset

 
\noun on
Atlas
\noun default
 with gesture tracking, user interaction, and video playback workloads.
 I use video playback is the primary example, because it is representative
 for a number of real-time and throughput applications due to its combination
 interesting properties.
\begin_inset CommandInset citation
LatexCommand cite
after "-2\\baselineskip"
key "Baiceanu:VideoScheduling"

\end_inset

 Specifically, execution times for the decoding of individual video frames
 are highly dynamic, as Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Total-and-Zoomed"

\end_inset

 illustrates.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/1-Introduction/Decoding_Times_Timeline.pdf

\end_inset


\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Total-and-Zoomed"

\end_inset

Total and Zoomed Views of Video Decoding Times
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Full Width
\begin_inset VSpace bigskip
\end_inset


\begin_inset Flex Emph
status collapsed

\begin_layout Plain Layout
I contribute a task model and a layered scheduler interface which allows
 applications to express timing and resource requirements.
 The developer-facing part of the interface only asks for parameters from
 the application domain, which simplifies programming.
 The scheduler-facing part provides look-ahead information on future application
 behavior.
 A runtime library employs machine learning to mediate between the two layers.
 I claim that 
\noun on
Atlas
\noun default
 is uniquely able to anticipate deadline misses before they occur.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
The scheduler design
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Roitzsch:ATLAS"

\end_inset

 rests upon the following architectural building blocks:
\end_layout

\begin_layout Description
Deadlines are a natural way to express timing requirements.
 Developers know about timing constraints, because they are part of the
 application’s problem domain.
 Programmatically exposing deadlines informs the scheduler of application
 timing requirements.
\end_layout

\begin_layout Description
Execution
\begin_inset space \space{}
\end_inset

times allow the scheduler to allocate time for jobs,
\begin_inset CommandInset citation
LatexCommand cite
after "-1\\baselineskip"
key "Mercer:CapacityReserve"

\end_inset

 calculate a schedule, and anticipate deadline misses.
 However, execution times are hard to obtain for developers because they
 depend on the end-user hardware.
 
\noun on
Atlas
\noun default
 resolves this impedance mismatch with an indirection: An estimator between
 the application and the system-level scheduler decouples the interface
 as seen by the developer from the lower-level interface of the scheduler.
 Developers provide 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
workload metrics
\end_layout

\end_inset

 to the estimator, which uses machine learning to infer execution time predictio
ns.
\end_layout

\begin_layout Description
Overload
\begin_inset space \space{}
\end_inset

Detection replaces traditional real-time admission, which uses a-priori
 information to prevent overload.
 I object to overruling a user decision, so 
\noun on
Atlas
\noun default
 will never reject work.
 However, I demonstrate that 
\noun on
Atlas
\noun default
 can detect overload situations before they occur.
\end_layout

\begin_layout Description
Look-Ahead replaces the infinite clairvoyance offered by periodic tasks.
 
\noun on
Atlas
\noun default
 opts for an explicit submission of future jobs.
\end_layout

\begin_layout Standard
Specifying deadlines and submitting jobs are an application responsibility,
 because only the developer has the necessary domain knowledge.
 Execution times depend on the workload the application is currently processing,
 like the video the user chose to play.
 But distributing CPU time requires global supervision, because jobs from
 different applications must be ordered to respect their individual time
 constraints.
 Therefore, application components must work with the global scheduler in
 a unified solution.
\end_layout

\begin_layout Section
End-to-End Integration
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset VSpace 60pt
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename Figures/3-Real-Time/Vertical_Integration_Overview.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Vertical-Integration"

\end_inset

Vertical Integration
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Vertical-Integration"

\end_inset

 illustrates the cooperation between the 
\noun on
Atlas
\noun default
 layers: Metrics collected from the workload are passed to a machine learning
 component to predict job execution times.
 The application propagates these predictions together with deadlines to
 the scheduler before the job runs.
 The scheduler orders jobs from all application to provide timely execution.
 Application and scheduler stay in sync about which job is currently active,
 allowing the application to associate the right work with each job to ensure
 timely processing.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
The architectural overview
\end_layout

\end_inset

 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Architectural-Overview"

\end_inset

 reflects the conceptual layers just discussed.
 Applications inspect their workload and talk to a local estimator component,
 which is linked to the application as a library.
 This component implements the 
\noun on
Atlas
\noun default
 interface as seen by the application developer.
 It remembers submitted jobs in a local queue until they have run to completion.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/3-Real-Time/Architectural_Overview.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Architectural-Overview"

\end_inset

Architectural Overview
\end_layout

\end_inset


\begin_inset VSpace 5pt
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The estimator forwards all its jobs to the system-wide scheduler, which
 queues them for execution.
 The two interface layers use two different kinds of job descriptions 
\begin_inset Formula $J$
\end_inset

 and 
\begin_inset Formula $J'$
\end_inset

 to represent a job in the system.
\end_layout

\begin_layout Standard
At the scheduler level, each job is described as a pair 
\begin_inset Formula $J_{i,j}=(e_{i,j},d_{i,j})$
\end_inset

 of an estimated execution time 
\begin_inset Formula $e_{i,j}$
\end_inset

 and an absolute deadline 
\begin_inset Formula $d_{i,j}$
\end_inset

.
 Applications can release jobs whenever they want, no minimum inter-release
 time and consequently no maximum time demand can be assumed.
 While the deadlines 
\begin_inset Formula $d_{i,j}$
\end_inset

 are provided by the application developer directly, the execution times
 
\begin_inset Formula $e_{i,j}$
\end_inset

 are not.
\end_layout

\begin_layout Standard
The application provides its estimator with job descriptions 
\begin_inset Formula $J'_{i,j}=(\underline{m}_{i,j},d_{i,j})$
\end_inset

 consisting of a vector 
\begin_inset Formula $\underline{m}_{i,j}$
\end_inset

 of workload metrics and the deadline as seen by the scheduler.
 From the metrics, the estimator derives approximate execution times before
 the job executes.
 Workload metrics are a vector of non-negative real numbers describing the
 computational weight of the workload.
 The estimator expects a subset of them to correlate positively with the
 execution time.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
The estimator
\end_layout

\end_inset

 exposes the following interface primitives:
\end_layout

\begin_layout Description
submit(
\begin_inset Formula $i$
\end_inset

,
\begin_inset space \space{}
\end_inset


\begin_inset Formula $J'_{i,j}\,$
\end_inset

) As soon as an application learns about a job it needs to perform, it should
 register the job with 
\noun on
Atlas
\noun default
.
 The application announces an identifier 
\begin_inset Formula $i$
\end_inset

 of the task this job belongs to and a job description 
\begin_inset Formula $J'_{i,j}=(\underline{m}_{i,j},d_{i,j})$
\end_inset

 that includes a deadline 
\begin_inset Formula $d_{i,j}$
\end_inset

 and a vector 
\begin_inset Formula $\underline{m}_{i,j}$
\end_inset

 of workload metrics.
 The estimator uses 
\begin_inset Formula $\underline{m}_{i,j}$
\end_inset

 and its internal training state to predict the job’s execution time 
\begin_inset Formula $e_{i,j}$
\end_inset

 and forwards the resulting job 
\begin_inset Formula $J_{i,j}=(e_{i,j},d_{i,j})$
\end_inset

 to the scheduler.
 It keeps the job 
\begin_inset Formula $J'_{i,j}$
\end_inset

 in its local queue to automatically train the estimation once the actual
 execution time of the job is known.
\end_layout

\begin_layout Description
next(
\begin_inset space \thinspace{}
\end_inset

) Because jobs execute back to back within a task, this primitive notifies
 the estimator that the current job 
\begin_inset Formula $J'_{i,j}$
\end_inset

 within task 
\begin_inset Formula $\tau_{i}$
\end_inset

 completed and that the next job 
\begin_inset Formula $J'_{i,j+1}$
\end_inset

 should start.
 The identity of the caller invoking 
\emph on
next
\emph default
 implicitly determines the task number 
\begin_inset Formula $i$
\end_inset

.
 The estimator is trained with the actual execution time 
\begin_inset Formula $t_{i,j}$
\end_inset

 of the just finished job and the metrics vector 
\begin_inset Formula $\underline{m}_{i,j}$
\end_inset

 stored during 
\emph on
submit
\emph default
.
 Then the execution time measurement for 
\begin_inset Formula $t_{i,j+1}$
\end_inset

 starts.
 The 
\emph on
next
\emph default
 primitive also informs the scheduler of the job switch.
 If the scheduler decides to run a different task, 
\emph on
next
\emph default
 will block in the kernel until the scheduler picks the caller again.
\end_layout

\begin_layout Standard
Look-ahead knowledge can build up in the scheduler, when jobs are submitted
 early before their execution.
 Because it encourages such a programming style, 
\noun on
Atlas
\noun default
 integrates with the emerging trend of asynchronous lambdas.
\begin_inset CommandInset citation
LatexCommand cite
key "Sutter:LambdasEverywhere"

\end_inset


\end_layout

\begin_layout Standard
Lambdas are a programming language feature that turns a piece of executable
 code into an object that can be stored in work queues for later, asynchronous
 execution.
 
\noun on
Atlas
\noun default
 uses lambdas to represent real-time jobs.
\end_layout

\begin_layout Section
Lambdas with Deadlines
\end_layout

\begin_layout Standard
Integration of the 
\noun on
Atlas
\noun default
 primitives with an asynchronous lambda runtime helps to reduce the development
 overhead of adding real-time support to applications.
 Therefore, I implement a subset of the Grand Central Dispatch (GCD) infrastruct
ure
\begin_inset CommandInset citation
LatexCommand cite
key "Apple:GrandCentralDispatchIntro"

\end_inset

 with built-in 
\noun on
Atlas
\noun default
 support.
 GCD is Apple’s implementation of asynchronous lambdas, but uses the term
 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
block
\end_layout

\end_inset

 instead of lambda.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
The key GCD function call is 
\begin_inset Flex NoWrap
status collapsed

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
dispatch_async(q, b)
\end_layout

\end_inset


\end_layout

\end_inset

.
\begin_inset CommandInset citation
LatexCommand cite
key "Apple:GrandCentralDispatchRef"

\end_inset

 It submits block 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
b
\end_layout

\end_inset

 to a queue 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
q
\end_layout

\end_inset

.
 The GCD runtime will execute the block later at its own convenience using
 an automatically managed background thread.
 To integrate 
\noun on
Atlas
\noun default
 scheduling, I augmented 
\begin_inset Flex NoWrap
status collapsed

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
dispatch_async
\end_layout

\end_inset


\end_layout

\end_inset

 with a job description containing three additional arguments:
\end_layout

\begin_layout Itemize
\begin_inset Argument
status collapsed

\begin_layout Plain Layout
noitemsep
\end_layout

\end_inset

the absolute deadline,
\end_layout

\begin_layout Itemize
the size of the metrics vector, and
\end_layout

\begin_layout Itemize
an array holding the metrics.
\end_layout

\begin_layout Standard
The signature of the resulting new function is:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	double deadline;
\end_layout

\begin_layout Plain Layout

	size_t metrics_count;
\end_layout

\begin_layout Plain Layout

	const double *metrics;
\end_layout

\begin_layout Plain Layout

} atlas_job_t;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void
\end_layout

\begin_layout Plain Layout

dispatch_async_atlas(dispatch_queue_t queue,
\end_layout

\begin_layout Plain Layout

                     atlas_job_t job,
\end_layout

\begin_layout Plain Layout

                     dispatch_block_t block);
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
The implementation of 
\begin_inset Flex NoWrap
status collapsed

\begin_layout Plain Layout
\noindent
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
\noindent
dispatch_async_atlas
\end_layout

\end_inset


\end_layout

\end_inset

 enqueues the block and calls 
\emph on
submit
\emph default
 to inform the 
\noun on
Atlas
\noun default
 estimator about a new job 
\begin_inset Formula $J'_{i,j}$
\end_inset

 with the given absolute deadline and metrics.
 The work queue corresponds to the task 
\begin_inset Formula $\tau_{i}$
\end_inset

.
 The estimator predicts the execution time for the job and forwards it to
 the scheduler.
\end_layout

\begin_layout Standard
Every work queue comes with an associated worker thread.
 It runs an endless loop, which first calls the 
\emph on
next
\emph default
 primitive.
 The thread can block until the scheduler wants the next job to start.
 When 
\emph on
next
\emph default
 returns, the worker dequeues the next block and executes it.
 After the block completes, its measured execution time trains the estimator.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Job-Lifetime"

\end_inset

 summarizes the lifetime of a job from initial submission to final execution.
 The interplay between GCD runtime, estimator, and system-wide scheduler
 ensures, that the timely release of jobs in the kernel translates to timely
 processing of the application workload.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/3-Real-Time/Job_Lifetime.svg

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Job-Lifetime"

\end_inset

A Job’s Life Through the Interface Layers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To the best of my knowledge, the combination of asynchronous lambdas and
 real-time jobs has not been explored yet.
 A different example of connecting real-time and programming concepts was
 the Comquad project, which introduced timing contracts
\begin_inset CommandInset citation
LatexCommand cite
key "Haertig:COMQUAD"

\end_inset

 into component-based development.
\end_layout

\begin_layout Section
Execution Time Prediction
\end_layout

\begin_layout Standard

\noun on
Atlas
\noun default
 uses workload metrics from the application domain instead of calling on
 developers to provide actual execution times.
 The developer should choose metrics on a “larger value means more work”
 basis.
 Expected iteration counts of loops or the expected number of times an expensive
 function is called are good candidates.
\begin_inset CommandInset citation
LatexCommand cite
key "Goldsmith:TrendProf"

\end_inset

 A 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
linear auto-regressive predictor
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Stoer:Numerics"

\end_inset

 produces execution time estimates from the metrics.
\end_layout

\begin_layout Standard
The estimator conceptually collects a history of metrics vectors in a metrics
 matrix 
\begin_inset Formula $M$
\end_inset

, where each individual vector 
\begin_inset Formula $\underline{m}_{j}$
\end_inset

 contributes a row of the matrix.
 All elements are real values.
 For jobs already executed, the estimator also knows the actual, measured
 execution times 
\begin_inset Formula $t_{j}$
\end_inset

 of the jobs and collects them in a column vector 
\begin_inset Formula $\underline{t}$
\end_inset

.
 To predict execution times of future jobs, the estimator uses this history
 to obtain a coefficient vector 
\begin_inset Formula $\underline{x}$
\end_inset

 that approximates the execution times when applied to past metrics:
\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace -7pt
\end_inset


\begin_inset Formula 
\[
\left\Vert M\underline{x}-\underline{t}\right\Vert _{2}\rightarrow\min_{\underline{x}}
\]

\end_inset

Given such coefficients 
\begin_inset Formula $\underline{x}$
\end_inset

 and a metrics vector 
\begin_inset Formula $\underline{m}$
\end_inset

 of a new job description 
\begin_inset Formula $J'$
\end_inset

, the estimator can calculate the execution time prediction as a dot product
 of both:
\begin_inset Formula 
\[
e=\underline{m}\cdot\underline{x}
\]

\end_inset

The actual implementation does not need to remember the complete metrics
 history, but employs an updating predictor based on Givens Rotations.
\begin_inset CommandInset citation
LatexCommand cite
key "Schwetlick:Numerics"

\end_inset

 I also developed countermeasures against numerical instability problems:
 An 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
\noindent
aging factor
\end_layout

\end_inset

 prevents the estimator from staleness and inflexibility.
 A 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
\noindent
column contribution threshold
\end_layout

\end_inset

 automatically selects a stable subset of the metrics to prevent overfitting.
 These mechanisms increase the estimator’s ease of use for developers.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
To predict execution times for video decoding,
\end_layout

\end_inset

 a developer with domain knowledge selects the metrics by reasoning about
 the decoding process.
\begin_inset CommandInset citation
LatexCommand cite
key "Roitzsch:Predict"

\end_inset

 To validate its applicability for a complex real-time application, I integrated
 
\noun on
Atlas
\noun default
 support into the FFplay video player on Linux.
 The design of the 
\noun on
Atlas
\noun default
 interface simplifies the necessary modifications: Unlike the classical
 periodic task model, deadlines can be placed arbitrarily.
 Unlike fair-share schedulers, no knowledge of surrounding applications
 and their load is needed.
 Unlike task models based on execution times, 
\noun on
Atlas
\noun default
 is independent of the user’s hardware.
 The estimator uses the workload metrics to derive approximate execution
 times.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
I compare the prediction accuracy
\end_layout

\end_inset

 using three alternatives for the metrics selected by the developer: The
 first version uses no metrics and consequently does not exploit workload
 insights.
 Prediction are based on previous execution times alone.
 I call this alternative 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
time only
\end_layout

\end_inset

 and it serves as a lower bound for prediction accuracy.
\end_layout

\begin_layout Standard
The option I call 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
full metrics
\end_layout

\end_inset

 uses deep workload insight, but requires offline preprocessing of videos
 to embed the video metrics.
 The MPEG-
\begin_inset Formula $4$
\end_inset


\begin_inset space ~
\end_inset

Part
\begin_inset space ~
\end_inset

2 video standard
\begin_inset CommandInset citation
LatexCommand cite
key "MPEG4-2"

\end_inset

 describes a complexity estimation header which optionally contains video
 metadata similar to my metrics.
 The size overhead from the embedded metrics amounts to a geometric mean
 of 
\begin_inset Formula $0.3\%$
\end_inset

 over all test videos.
 The full metrics with stream preprocessing serve as an upper bound for
 implementor effort and resulting prediction accuracy.
 This option demonstrates, how good predictions can get when designers are
 willing to apply an end-to-end approach and are able to engineer the data
 format of their application to support a desired non-functional property.
\end_layout

\begin_layout Standard
An intermediate option called 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
\noindent
reduced metrics
\end_layout

\end_inset

 is limited to information that can be obtained by the player at runtime
 from an unmodified bitstream.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/4-Prediction/Prediction_Comparison.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Prediction-Accuracy-Decoder"

\end_inset

Prediction Accuracy for Test Videos
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Prediction-Accuracy-Decoder"

\end_inset

 shows that workload awareness improves prediction accuracy over a purely
 time-based predictor.
 Error bars represent the lower and upper quartile of the per-frame relative
 prediction errors.
 The reduced metrics, which do not require preprocessing provide a good
 middle ground, whereas the full set of metrics offers the highest precision,
 with typical relative errors of less than 
\begin_inset Formula $10\%$
\end_inset

.
 The convincing results indicate that the prediction provides accurate estimates
 over the entire range of test videos, regardless of their length, encoding
 profile, or resolution.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/4-Prediction/Prediction_Timeline.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Prediction-Zoom"

\end_inset

Zoomed View of Prediction Alternatives
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Prediction-Zoom"

\end_inset

 zooms in on a section of the Hunger Games video to illustrate that the
 full-metrics prediction tightly follows the large variations of the decoding
 time, while time-only prediction yields a long-term moving average.
 Across the test videos, the predictor introduces a runtime overhead of
 only 
\begin_inset Formula $0.1\%$
\end_inset

.
\end_layout

\begin_layout Section
System Scheduler
\end_layout

\begin_layout Standard
Multiple 
\noun on
Atlas
\noun default
 applications can independently submit jobs, which compete for CPU time.
 Because we cannot assume applications to trust each other, a privileged
 management component needs to oversee and enforce the allocation of time.
 We have to keep in mind underestimation of reported execution times is
 possible.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/5-Scheduler/Scheduler_Layers.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Linux-Scheduler-Layers"

\end_inset

Linux Scheduler Layers
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 8pt
\end_inset


\end_layout

\end_inset

The 
\noun on
Atlas
\noun default
 scheduler comes as a kernel patch to Linux version
\begin_inset space ~
\end_inset

3.5.7.
 As Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Linux-Scheduler-Layers"

\end_inset

 illustrates, it adds two new layers to the Linux scheduler hierarchy.
 It integrates in an otherwise unmodified Ubuntu Linux kernel.
 I show that 
\noun on
Atlas
\noun default
 improves the responsiveness of applications with graphical user interfaces,
 thus I believe real-time programming should become the default rather than
 the rare special case it is today.
 
\noun on
Atlas
\noun default
 helps to pave the way by providing a simple scheduler interface on a general-pu
rpose operating system.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
The scheduler design
\end_layout

\end_inset

 combines cues from existing algorithms: Earliest Deadline First (EDF) and
 Latest Release Time First (LRT).
\begin_inset CommandInset citation
LatexCommand cite
key "Liu:RealTimeSystems"

\end_inset

 The scheduler keeps a list of submitted jobs, which it orders by deadline,
 similar to EDF.
\end_layout

\begin_layout Standard
To make a scheduling decision, the scheduler calculates the 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
available slack
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Literature sometimes uses the term static slack, but usually with schedules
 based on worst-case execution times.
 
\noun on
Atlas
\noun default
 estimates job execution times based on runtime knowledge, so the word “static”
 is inappropriate.
\end_layout

\end_inset

at the current time instant 
\begin_inset Formula $t_{now}$
\end_inset

: Every job 
\begin_inset Formula $J_{i}$
\end_inset

 comes with a current per-job slack 
\begin_inset Formula $s_{i}(t_{now})$
\end_inset

, which is the difference between the time remaining until 
\begin_inset Formula $J_{i}$
\end_inset

’s absolute deadline 
\begin_inset Formula $d_{i}$
\end_inset

 and the sum of all execution times of jobs scheduled to run between 
\begin_inset Formula $t_{now}$
\end_inset

 and 
\begin_inset Formula $d_{i}$
\end_inset

: 
\begin_inset Formula 
\[
s_{i}(t_{now})=\left(d_{i}-t_{now}\right)-\sum_{\left\{ J_{k}\mid\mathrm{job\: scheduled\: between}\: t_{now}\:\mathrm{and}\: d_{i}\right\} }e_{k}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename Figures/5-Scheduler/Slack_Calculation.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:Slack-Calculation"

\end_inset

Slack Calculation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:Slack-Calculation"

\end_inset

 visualizes this calculation.
 The available slack 
\begin_inset Formula $s(t_{now})$
\end_inset

 is the minimum of all 
\begin_inset Formula $s_{i}(t_{now})$
\end_inset

.
 The intuition behind available slack is that we can safely delay execution
 of all upcoming jobs for another 
\begin_inset Formula $s(t_{now})$
\end_inset

 time units without violating any timing constraints.
\begin_inset CommandInset citation
LatexCommand cite
key "Tia:Slack"

\end_inset

 The calculation of available slack ensures, that there is still enough
 time to finish all jobs before their deadline.
\end_layout

\begin_layout Standard
Similar to LRT, 
\noun on
Atlas
\noun default
 is not work-conserving and only dispatches jobs when available slack is
 zero.
 All slack time is donated to Linux’ default scheduler CFS for three reasons:
\end_layout

\begin_layout Itemize
\begin_inset Argument
status collapsed

\begin_layout Plain Layout
noitemsep
\end_layout

\end_inset

When slack calculation reveals that no real-time job needs to run, we can
 use the CPU to improve response times for non-real-time work.
\begin_inset CommandInset citation
LatexCommand cite
key "Lehoczky:Slack"

\end_inset


\end_layout

\begin_layout Itemize
Any job that overruns its reported execution time estimate is demoted to
 CFS.
 Slack donation to CFS therefore allows delayed jobs to catch up sooner.
\end_layout

\begin_layout Itemize
To counteract underestimated execution times, the earliest-deadline job
 in 
\noun on
Atlas
\noun default
 is also eligible for scheduling by CFS.
 This 
\begin_inset Flex SmallCaps
status collapsed

\begin_layout Plain Layout
head start
\end_layout

\end_inset

 mechanism awards jobs extra CPU time in CFS that is not accounted against
 the reported execution time.
\end_layout

\begin_layout Standard
I have proved that the 
\noun on
Atlas
\noun default
 scheduling algorithm is optimal regarding schedulability with the same
 preconditions as EDF.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
The scheduler contract
\end_layout

\end_inset

 provided by 
\noun on
Atlas
\noun default
 is comprehensible and useful.
 To receive strong guarantees, submitted execution times must be precise,
 jobs must not self-suspend, and deadlines must never decrease along dependencie
s.
 Developers can reason about these requirements by analyzing just their
 own application code, without making assumptions about system context or
 other applications.
 In return, 
\noun on
Atlas
\noun default
 guarantees optimal schedulability.
\end_layout

\begin_layout Standard
For imperfect real-time applications, where the developer did not spend
 the analysis effort or where technical reasons prevent satisfying all requireme
nts, 
\noun on
Atlas
\noun default
 employs band-aid mechanisms to uphold good service: Jobs get a free head
 start and 
\noun on
Atlas
\noun default
 donates all slack to CFS, allowing late jobs to catch up quickly.
 
\noun on
Atlas
\noun default
 always ensures that misbehaving jobs never interfere with the timeliness
 of behaving jobs.
\end_layout

\begin_layout Section
Timely Service
\end_layout

\begin_layout Standard
I evaluate 
\noun on
Atlas
\noun default
’ real-time behavior using three workloads: gesture tracking, user interface
 responsiveness, and the FFplay video player.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
Bodytrack
\end_layout

\end_inset

 is part of the Parsec
\begin_inset space ~
\end_inset

3.0 benchmark suite
\begin_inset CommandInset citation
LatexCommand cite
after "-50pt"
key "Bienia:Parsec"

\end_inset

 and implements tracking of a human body’s 
\begin_inset Formula $\mathrm{3D}$
\end_inset

 pose from camera images.
\begin_inset CommandInset citation
LatexCommand cite
after "-32pt"
key "Jacob:RBI"

\end_inset

 I modified Bodytrack to enable 
\noun on
Atlas
\noun default
 real-time scheduling with the requirement of processing each camera image
 within 
\begin_inset Formula $250\,\mathrm{ms}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/6-Evaluation/Bodytrack_Schedule.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Bodytrack-Scheduling"

\end_inset

Bodytrack Scheduling
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Bodytrack-Scheduling"

\end_inset

 shows how 
\noun on
Atlas
\noun default
 protects the real-time work from competing background load.
 The first subfigure illustrates the behavior of a Bodytrack run with no
 concurrent load.
 The application progresses linearly through the captured image sequence.
 Every job meets its deadline.
 The second subfigure demonstrates scheduling behavior of the Linux default
 CFS scheduler, when Bodytrack competes with background load, which starts
 15
\begin_inset space ~
\end_inset

seconds into the experiment and stops at time instant 45.
 Bodytrack’s progress slows down because the background load receives too
 much CPU time.
 When the background load recedes, Bodytrack tries to catch up.
 Scheduling under 
\noun on
Atlas
\noun default
 avoids this problem.
 As the third subfigure confirms, 
\noun on
Atlas
\noun default
 successfully schedules Bodytrack according to its specified timing requirements.
 Background load throttles as needed, without requiring developers to report
 execution times.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
Graphical user interface code
\end_layout

\end_inset

 has timing requirements much different from recurring work.
 Spontaneous user interaction releases jobs without prior warning and not
 bound to a period.
 I developed a test application shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mar:User-Interface-Test"

\end_inset

.
 A click on the only button triggers work that uses the 
\begin_inset Flex NoWrap
status collapsed

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
strcasestr()
\end_layout

\end_inset


\end_layout

\end_inset

 function to simulate searching a word in a document.

\noun on
 Atlas
\noun default
 scheduling is integrated into the button click handler with just seven
 lines of code as shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Pseudocode-ATLAS"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float marginfigure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Figures/6-Evaluation/UI_Worker.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mar:User-Interface-Test"

\end_inset

User Interface Test Application
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace 100pt
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset VSpace -6pt
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double metrics[] = { size };
\end_layout

\begin_layout Plain Layout

atlas_job_t job = {
\end_layout

\begin_layout Plain Layout

	.deadline = atlas_now() + 0.1,
\end_layout

\begin_layout Plain Layout

	.metrics_count = 1,
\end_layout

\begin_layout Plain Layout

	.metrics = metrics
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

dispatch_async_atlas(queue, job, ^{ scan_document(size); });
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Pseudocode-ATLAS"

\end_inset


\noun on
Atlas
\noun default
 Scheduling in User Interface Code
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
I specify a relative deadline of 
\begin_inset Formula $100\,\mathrm{ms}$
\end_inset

, because this is the typical threshold where users perceive an application
 reaction as immediate.
\begin_inset CommandInset citation
LatexCommand cite
after "-52pt"
key "Card:RealTimeUI"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename Data/6-Evaluation/UI_Worker_Schedule.pdf

\end_inset


\begin_inset VSpace -6pt
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Worker-Makespan"

\end_inset

Makespan Histograms
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Worker-Makespan"

\end_inset

 demonstrates the benefit of using 
\noun on
Atlas
\noun default
 by visualizing the job makespan
\begin_inset space \thinspace{}
\end_inset

—
\begin_inset space \thinspace{}
\end_inset

the time spent between release and completion.
 Makespan lengths below 
\begin_inset Formula $100\,\mathrm{ms}$
\end_inset

 meet the specified deadline.
 The first subfigure shows the application scheduled by CFS and executing
 with no concurrent load.
 All jobs finish before their deadline.
 We observe the same completion behavior in the second subfigure, where
 the application is scheduled by 
\noun on
Atlas.

\noun default
 Without background load, 
\noun on
Atlas
\noun default
-scheduled jobs finish early thanks to the CFS head start mechanism.
\end_layout

\begin_layout Standard
The third and fourth subfigures add background load.
 When scheduled by CFS, the competing load causes excessive deadline misses,
 with jobs taking up to one second to complete.
 The last subfigure illustrates the 
\noun on
Atlas
\noun default
 behavior of scheduling real-time work as late as possible, but reliably
 completing all jobs before their deadline.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
To evaluate video smoothness,
\end_layout

\end_inset

 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Video-Smoothness-ATLAS"

\end_inset

 repeats the earlier experiment of playing a video and adding background
 load, comparing the original CFS behavior with 
\noun on
Atlas.
 
\noun default
The interval between the display instants of two consecutive frames should
 be a constant 
\begin_inset Formula $41.7\,\mathrm{ms}$
\end_inset

, which 
\noun on
Atlas
\noun default
 achieves almost perfectly.
 Visual inspection by blind comparison with twelve human viewers confirms
 the smoothness.
 Nine of the twelve viewers could not discern playback jitter, two viewers
 preferred a standalone CFS version without background load, one viewer
 preferred the 
\noun on
Atlas
\noun default
 version.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/6-Evaluation/Background.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Video-Smoothness-ATLAS"

\end_inset

Video Smoothness with Competing Background Load
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The next experiment compares the three workload metric alternatives to predict
 video decoding times.
 The following two figures compare mean frame display jitter, which is the
 average difference between the intended and actual display instants of
 each frame.
 Error bars indicate the lower and upper quartiles of the jitter.
 Lower values thus represent smoother playback.
 All videos are played with competing background load over their entire
 duration.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Video-Smoothness-Scheduler"

\end_inset

 demonstrates the results for scheduling under CFS, which shows unacceptable
 playback behavior for high resolution videos.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/6-Evaluation/Scheduling_Comparison_All.pdf

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Video-Smoothness-Scheduler"

\end_inset

Video Smoothness with Different Schedulers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
All
\noun on
 Atlas
\noun default
 options perform significantly better.
 Interestingly, CFS is able to successfully schedule the two low resolution
 videos in the mix, because of their lower resource use.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Video-Smoothness-Metrics"

\end_inset

 shows the same values as the preceding figure, but removes the CFS bars
 to zoom in on the 
\noun on
Atlas
\noun default
 behavior.
 All metrics options exhibit typical jitter of less than 
\begin_inset Formula $20\,\mathrm{ms}$
\end_inset

, but we also see an advantage of the reduced and full workload metrics
 over a prediction based only on execution times.
 The reduced metrics cut the average jitter in half for all but the Charlie
 video.
 The full metrics further improve the scheduling behavior, down to 
\begin_inset Formula $5\,\mathrm{ms}$
\end_inset

 jitter.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
enlargethispage{2
\backslash
baselineskip}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset Graphics
	filename Data/6-Evaluation/Scheduling_Comparison_ATLAS.pdf

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Video-Smoothness-Metrics"

\end_inset

Video Smoothness with Different Metrics Options
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
By submitting jobs
\end_layout

\end_inset

 before they are due for execution, applications provide the scheduler with
 look-ahead knowledge.
 This foresight enables 
\noun on
Atlas
\noun default
 to anticipate deadline misses before they occur by forecasting job completion
 times.
 Unfortunately, such forecasts will aggregate a number of errors: all inaccuraci
es in the predicted execution times and any blocking delay, clock jitter
 or scheduling overhead will accumulate in the completion prognosis.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Completion-Forecast-Error"

\end_inset

 illustrates that the forecast is still remarkably accurate.
 The x-coordinate marks, how early the forecast was generated relative to
 the job’s actual completion instant.
 The y-coordinate represents the error between forecasted and measured completio
n times, with lower and upper quartiles given by error lines.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Data/6-Evaluation/Miss-Detect_Forecast.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Completion-Forecast-Error"

\end_inset

Completion Forecast Error Relative to Forecast Horizon
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
As expected, forecast accuracy for a job improves, the closer we get to
 this job’s completion instant.
 While the time-only metrics are not competitive, the reduced and full metrics
 allow forecasts up to half a second before job completion with typical
 errors under 
\begin_inset Formula $35\,\mathrm{ms}$
\end_inset

, which is less than the video’s frame interval of 
\begin_inset Formula $41.7\,\mathrm{ms}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex NewThought
status collapsed

\begin_layout Plain Layout
These accurate forecasts
\end_layout

\end_inset

 of deadline misses inform applications early about upcoming overload situations
, allowing them to adapt by shedding load before the overhead occurs.
 No other scheduling system I am aware of features such look-ahead capabilities
 for complex and dynamic real-time applications.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Full Width
\begin_inset Flex Emph
status collapsed

\begin_layout Plain Layout
I have presented 
\noun on
Atlas,
\noun default
 the Auto-Training Look-Ahead Scheduler.
 It is designed to provide timeliness and overload detection, while being
 simple to use for developers.
 Its interface is aligned with the emerging programming paradigm of asynchronous
 lambdas.
 A custom GCD runtime mediates between application and scheduler, enabling
 developers to drive the entire machinery by way of a single function call:
 
\begin_inset Flex NoWrap
status collapsed

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
dispatch_async_atlas
\end_layout

\end_inset


\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset


\noun on
Atlas
\noun default
 offers a vertically integrated solution, fully implemented from application
 runtime and a linear auto-regressive estimator down to the kernel scheduler.
 On all layers, developers need to reflect only on application-local behavior
 and 
\noun on
Atlas
\noun default
 only asks for parameters from the application domain.
 Deadlines express timing requirements, workload metrics describe jobs.
 The estimator applies machine learning to automatically and hardware-independen
tly predict job execution times from the metrics with typical relative errors
 below 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
addfontfeature{Numbers={Lining}}
\end_layout

\end_inset

10%
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

The system scheduler orders jobs with proven optimality properties.
 
\noun on
Atlas
\noun default
 can service recurring and spontaneous work as well as complex applications.
 Video playback maintains display jitter below 5
\begin_inset space \thinspace{}
\end_inset

ms when competing against aggressive background load.
 Thanks to its unique look-ahead and prediction abilities, 
\noun on
Atlas
\noun default
 can accurately forecast overload situations up to half a second before
 they occur.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Bibliography/Thesis"
options "Bibliography/Thesis"

\end_inset


\end_layout

\end_body
\end_document
